<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood & Habits Tracker</title>

    <!-- Favicon and Fonts -->
    <link rel="icon" href="https://cdn-icons-png.flaticol.com/512/3448/3448338.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* Use the Inter font stack */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* Lighter gray */
        }

        /* Custom styling for the range input slider */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 24px; height: 24px;
            background: #4F46E5; /* Indigo */
            border-radius: 50%; cursor: grab;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            margin-top: -8px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing; transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px; height: 24px; background: #4F46E5;
            border-radius: 50%; cursor: grab; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px; background: #E0E7FF; /* Indigo-100 */
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-track {
            height: 8px; background: #E0E7FF; border-radius: 4px;
        }

        /* Styles for smooth modal transitions */
        .modal { transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }

        /* Styles for collapsible sections */
        .collapsible-content {
            max-height: 0; overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .collapsible-content.expanded { max-height: 1000px; } /* Increased max-height for potential content */

        /* Hide scrollbar but allow scrolling */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Calendar Styles */
        .calendar-grid { display: grid; grid-template-columns: repeat(7, minmax(0, 1fr)); }
        .calendar-day {
            min-height: 120px;
            transition: background-color 0.3s;
        }
        .calendar-day-other-month { color: #9ca3af; } /* text-gray-400 */
        .calendar-day-today { border: 2px solid #4F46E5; } /* border-indigo-600 */
        
        /* Active nav link style */
        .nav-link.active {
            background-color: #4f46e5;
            color: white;
        }
        .nav-link {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s, color 0.2s;
        }
        .nav-link:not(.active):hover {
            background-color: #eef2ff;
        }

        /* Basic loading text animation */
        @keyframes blink {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        .loading-text {
            animation: blink 1.5s infinite;
        }

        /* Breath Helper specific styles */
        .breathing-circle-container {
            width: 250px; height: 250px;
            border-radius: 50%;
            background-color: #A5B4FC; /* Light indigo */
            display: flex; justify-content: center; align-items: center;
            transition: transform 4s ease-in-out; /* Default transition */
            margin: 2rem auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .breathing-circle-container.breathing-in {
            transform: scale(1.25);
            background-color: #4F46E5; /* Darker indigo */
            transition: transform var(--inhale-duration) ease-in-out;
        }

        .breathing-circle-container.breathing-hold {
            transform: scale(1.25);
            background-color: #4F46E5; /* Darker indigo */
            transition: transform var(--hold-duration) linear; /* No transform, just holding state */
        }

        .breathing-circle-container.breathing-out {
            transform: scale(1);
            background-color: #A5B4FC; /* Light indigo */
            transition: transform var(--exhale-duration) ease-in-out;
        }

        .breathing-text {
            font-size: 1.5rem;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <!-- Main Application Container -->
    <div id="app-container" class="w-full max-w-7xl mx-auto bg-white rounded-2xl shadow-xl my-4 md:my-8 p-4 sm:p-6 md:p-8 flex flex-col gap-6 opacity-0 transition-opacity duration-500">
        
        <div id="user-info" class="absolute top-2 right-4 text-xs text-gray-400">Loading...</div>

        <header class="flex flex-col sm:flex-row justify-between items-center gap-4 border-b border-gray-200 pb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-indigo-600">Zenith Tracker</h1>
            <nav class="flex flex-wrap justify-center gap-1 sm:gap-2">
                <button class="nav-link active" data-target="dashboard-section">Dashboard</button>
                <button class="nav-link" data-target="mood-logging-section">Log Mood</button>
                <button class="nav-link" data-target="habit-tracking-section">Habits</button>
                <button class="nav-link" data-target="hydration-section">Hydration</button>
                <button class="nav-link" data-target="sleep-tracking-section">Sleep</button>
                <button class="nav-link" data-target="breath-helper-section">Breath</button>
                <button class="nav-link" data-target="calendar-section">Calendar</button>
                <button class="nav-link" data-target="analytics-section">Analytics</button>
                <button class="nav-link" data-target="recommendations-section">Recommendations</button>
                <button class="nav-link" data-target="utility-section">Utility</button> <!-- New Nav Link for Export/Import -->
            </nav>
        </header>

        <main>
            <div id="dashboard-section" class="content-section"></div>
            <div id="mood-logging-section" class="content-section hidden"></div>
            <div id="habit-tracking-section" class="content-section hidden"></div>
            <div id="hydration-section" class="content-section hidden"></div>
            <div id="sleep-tracking-section" class="content-section hidden"></div>
            <div id="breath-helper-section" class="content-section hidden"></div>
            <div id="calendar-section" class="content-section hidden"></div>
            <div id="analytics-section" class="content-section hidden"></div>
            <div id="recommendations-section" class="content-section hidden"></div>
            <div id="utility-section" class="content-section hidden"></div> <!-- New Content Section -->
        </main>
    </div>

    <!-- Modals (Habit & Confirmation) -->
    <div id="habit-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 invisible opacity-0">
        <div class="modal-content transform -translate-y-10 bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 id="habit-modal-title" class="text-xl font-bold">Add New Habit</h2>
                <button id="close-habit-modal" class="text-gray-400 hover:text-gray-600 text-3xl leading-none">&times;</button>
            </div>
            <!-- Moved Suggest Habits button outside the form for better UI -->
            <div class="mb-4 text-right">
                <button type="button" id="suggest-habits-btn" class="px-3 py-1 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 text-sm flex items-center gap-1 inline-flex">âœ¨Suggest Habits</button>
            </div>
            <form id="habit-form" class="space-y-4">
                <input type="hidden" id="habit-id">
                <div>
                    <label for="new-habit-name" class="block text-sm font-medium text-gray-700">Habit Name</label>
                    <input type="text" id="new-habit-name" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., Meditate for 10 minutes">
                </div>
                <!-- Updated habit-suggestions-output with border and padding -->
                <div id="habit-suggestions-output" class="text-gray-600 text-sm mt-2 italic p-2 rounded-md border border-dashed border-gray-300 hidden"></div>
                <div>
                    <label for="habit-frequency" class="block text-sm font-medium text-gray-700">Frequency</label>
                    <select id="habit-frequency" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="daily">Daily</option>
                        <option value="specific-days">Specific Days</option>
                    </select>
                </div>
                <div id="specific-days-container" class="collapsible-content"><div class="flex flex-wrap gap-2"></div></div>
                <div class="flex gap-4">
                    <div class="flex-1">
                        <label for="habit-start-date" class="block text-sm font-medium text-gray-700">Start Date</label>
                        <input type="date" id="habit-start-date" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div class="flex-1">
                        <label for="habit-end-date" class="block text-sm font-medium text-gray-700">End Date (Optional)</label>
                        <input type="date" id="habit-end-date" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                </div>
                <div>
                    <label for="habit-reminder-time" class="block text-sm font-medium text-gray-700">Reminder Time (Optional)</label>
                    <input type="time" id="habit-reminder-time" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                </div>

                <!-- New: Habit Goals -->
                <div class="border-t border-gray-200 pt-4 mt-4">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Habit Goal (Optional)</h3>
                    <div class="flex gap-2 mb-3">
                        <div class="flex-1">
                            <label for="habit-goal-type" class="block text-sm font-medium text-gray-700">Goal Type</label>
                            <select id="habit-goal-type" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                                <option value="">None</option>
                                <option value="count">Count (e.g., times completed)</option>
                                <option value="duration">Duration (e.g., total minutes)</option>
                            </select>
                        </div>
                        <div class="flex-1">
                            <label for="habit-goal-value" class="block text-sm font-medium text-gray-700">Target Value</label>
                            <input type="number" id="habit-goal-value" min="1" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="e.g., 10">
                        </div>
                    </div>
                    <div>
                        <label for="habit-goal-unit" class="block text-sm font-medium text-gray-700">Unit (e.g., "books", "minutes", "times")</label>
                        <input type="text" id="habit-goal-unit" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="e.g., pages, minutes, times">
                    </div>
                </div>

                <div>
                    <label for="habit-color-picker" class="block text-sm font-medium text-gray-700">Color</label>
                    <input type="color" id="habit-color-picker" value="#A5B4FC" class="mt-1 w-full h-10 border border-gray-300 rounded-md cursor-pointer">
                </div>
                <div class="flex justify-end gap-3 pt-4">
                    <button type="button" id="cancel-habit-modal" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Habit</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="confirm-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 invisible opacity-0">
        <div class="modal-content transform -translate-y-10 bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 text-center">
            <h2 id="confirm-modal-title" class="text-xl font-bold mb-4">Are you sure?</h2>
            <p id="confirm-modal-text" class="text-gray-600 mb-6">This action cannot be undone.</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-modal-cancel" class="px-6 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="confirm-modal-ok" class="px-6 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>

    <!-- Main Application Logic -->
    <script type="module">
        // --- App State & Local Storage Keys ---
        let moodLogs = [], habits = [], dailyHabitStatuses = [];
        let sleepLogs = []; 
        let breathLogs = []; 
        let habitStreaks = {};
        let moodChartInstance = null, habitChartInstance = null, hydrationChartInstance = null, sleepChartInstance = null, breathChartInstance = null;
        let currentCalendarDate = new Date();
        let hasInitialDataLoaded = false;
        let hasResetBeenChecked = false;

        // Hydration specific state
        let dailyWaterNeed = 0; // in ml
        let dailyIntake = 0; // in ml

        // Breathing exercise state
        let breathingInterval = null;
        let currentPhase = 'initial'; // 'initial', 'inhale', 'hold', 'exhale'
        let inhaleDuration = 4; // seconds
        let holdDuration = 4; // seconds
        let exhaleDuration = 4; // seconds
        let phaseTimeoutId = null;
        let sessionStartTime = null;

        // Local Storage Keys
        const LS_MOOD_LOGS = 'zenithTrackerMoodLogs';
        const LS_HABITS = 'zenithTrackerHabits';
        const LS_HABIT_STATUSES = 'zenithTrackerHabitStatuses';
        const LS_METADATA = 'zenithTrackerMetadata';
        const LS_HYDRATION_LOGS = 'zenithTrackerHydrationLogs';
        const LS_NOTIFICATIONS_SENT = 'zenithTrackerNotificationsSent';
        const LS_SLEEP_LOGS = 'zenithTrackerSleepLogs'; 
        const LS_BREATH_LOGS = 'zenithTrackerBreathLogs'; 

        // --- UI Element References ---
        const appContainer = document.getElementById('app-container');
        const userInfo = document.getElementById('user-info');
        const habitModal = document.getElementById('habit-modal');
        const confirmModal = document.getElementById('confirm-modal');
        const moodInsightOutput = document.createElement('div'); 
        moodInsightOutput.id = 'mood-insight-output';
        moodInsightOutput.className = 'bg-blue-100 text-blue-800 p-3 rounded-md mt-4 hidden';

        const habitSuggestionsOutput = document.getElementById('habit-suggestions-output'); 
        const sleepAnalysisOutput = document.createElement('div'); 
        sleepAnalysisOutput.id = 'sleep-analysis-output';
        sleepAnalysisOutput.className = 'bg-blue-100 text-blue-800 p-3 rounded-md mt-4 hidden';
        
        const journalPromptOutput = document.createElement('div');
        journalPromptOutput.id = 'journal-prompt-output';
        journalPromptOutput.className = 'bg-green-100 text-green-800 p-3 rounded-md mt-4 hidden';


        // --- Helper Functions ---
        const hexToRgb = (hex = '#ffffff') => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
        };
        const getTextColorForBackground = (hexColor) => {
            const [r, g, b] = hexToRgb(hexColor);
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255 > 0.5 ? 'text-gray-800' : 'text-white';
        };
        const formatDateTime = (date) => new Date(date)?.toLocaleString('en-US', { month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' }) || 'Invalid Date';
        const toYYYYMMDD = (date) => {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        const generateUniqueId = () => '_' + Math.random().toString(36).substr(2, 9); 

        // Beverage conversion factors (water equivalent per 1ml)
        const BEVERAGE_WATER_EQUIVALENT = {
            'water': 1.0,
            'tea': 1.0, 
            'coffee': 0.8, 
            'cold-drinks': 0.5, 
            'juice': 0.8 
        };

        const DRINK_COLORS = {
            'water': '#4F46E5', 
            'tea': '#10B981', 
            'coffee': '#EAB308', 
            'cold-drinks': '#EF4444', 
            'juice': '#F97316', 
            'remaining': '#E0E7FF' 
        };

        let notificationsSentToday = {}; 
        let hydrationLogs = {}; 
        
        // --- Local Storage Operations ---
        const loadData = () => {
            try {
                moodLogs = JSON.parse(localStorage.getItem(LS_MOOD_LOGS) || '[]').map(log => ({
                    ...log,
                    timestamp: new Date(log.timestamp) 
                }));
                habits = JSON.parse(localStorage.getItem(LS_HABITS) || '[]').map(habit => ({
                    ...habit,
                    createdAt: new Date(habit.createdAt) 
                }));
                dailyHabitStatuses = JSON.parse(localStorage.getItem(LS_HABIT_STATUSES) || '{}');
                
                sleepLogs = JSON.parse(localStorage.getItem(LS_SLEEP_LOGS) || '[]').map(log => ({
                    ...log,
                    date: new Date(log.date) 
                }));
                
                breathLogs = JSON.parse(localStorage.getItem(LS_BREATH_LOGS) || '[]').map(log => ({
                    ...log,
                    timestamp: new Date(log.timestamp)
                }));

                const metadata = JSON.parse(localStorage.getItem(LS_METADATA) || '{}');
                dailyWaterNeed = metadata.dailyWaterNeed || 0;
                
                hydrationLogs = JSON.parse(localStorage.getItem(LS_HYDRATION_LOGS) || '{}');
                const todayKey = toYYYYMMDD(new Date());
                dailyIntake = hydrationLogs[todayKey] ? hydrationLogs[todayKey].totalIntake : 0;

                console.log("Local Storage: Data loaded successfully.");
            } catch (e) {
                console.error("Local Storage: Error loading data", e);
                localStorage.clear();
                moodLogs = []; habits = []; dailyHabitStatuses = {}; dailyWaterNeed = 0; dailyIntake = 0;
                hydrationLogs = {}; 
                sleepLogs = []; 
                breathLogs = []; 
            }
        };

        const saveData = () => {
            localStorage.setItem(LS_MOOD_LOGS, JSON.stringify(moodLogs));
            localStorage.setItem(LS_HABITS, JSON.stringify(habits));
            localStorage.setItem(LS_HABIT_STATUSES, JSON.stringify(dailyHabitStatuses));
            localStorage.setItem(LS_METADATA, JSON.stringify({ dailyWaterNeed }));
            localStorage.setItem(LS_SLEEP_LOGS, JSON.stringify(sleepLogs)); 
            localStorage.setItem(LS_BREATH_LOGS, JSON.stringify(breathLogs)); 
            
            localStorage.setItem(LS_HYDRATION_LOGS, JSON.stringify(hydrationLogs));
            
            saveNotificationsSent(); 
            console.log("Local Storage: Data saved successfully.");
        };

        const loadNotificationsSent = () => {
            const todayKey = toYYYYMMDD(new Date());
            const stored = JSON.parse(localStorage.getItem(LS_NOTIFICATIONS_SENT) || '{}');
            notificationsSentToday = stored[todayKey] || {};
        };

        const saveNotificationsSent = () => {
            const todayKey = toYYYYMMDD(new Date());
            const allNotifications = JSON.parse(localStorage.getItem(LS_NOTIFICATIONS_SENT) || '{}');
            allNotifications[todayKey] = notificationsSentToday;
            localStorage.setItem(LS_NOTIFICATIONS_SENT, JSON.stringify(allNotifications));
        };
        
        // --- Modals and Navigation ---
        const toggleModal = (modal, show) => {
            const content = modal.querySelector('.modal-content');
            if (show) {
                modal.classList.remove('invisible', 'opacity-0');
                content.classList.remove('-translate-y-10');
            } else {
                modal.classList.add('opacity-0');
                content.classList.add('-translate-y-10');
                setTimeout(() => modal.classList.add('invisible'), 300);
            }
        };
        
        let confirmCallback = null;
        // Modified showConfirmation to accept custom button text and color
        const showConfirmation = (title, text, onConfirm, onCancel = () => {}, okButtonText = 'Confirm', okButtonColor = 'bg-red-600') => { 
            confirmModal.querySelector('#confirm-modal-title').textContent = title;
            confirmModal.querySelector('#confirm-modal-text').textContent = text;
            confirmCallback = onConfirm;

            const okButton = confirmModal.querySelector('#confirm-modal-ok');
            okButton.textContent = okButtonText;
            // Remove existing bg- and hover:bg- classes and add new ones
            okButton.className = okButton.className.split(' ').filter(cls => !cls.startsWith('bg-') && !cls.startsWith('hover:bg-')).join(' ');
            okButton.classList.add(okButtonColor);
            okButton.classList.add(`hover:${okButtonColor.replace('bg-', 'bg-')}-700`); // Simple hover color based on new color

            // Attach temporary listener for cancel to ensure onCancel is called only once
            const handleCancel = () => {
                onCancel();
                toggleModal(confirmModal, false);
                confirmModal.querySelector('#confirm-modal-cancel').removeEventListener('click', handleCancel); // Clean up
            };
            confirmModal.querySelector('#confirm-modal-cancel').addEventListener('click', handleCancel);
            toggleModal(confirmModal, true);
        };
        
        const showSection = (targetId) => {
            document.querySelectorAll('.content-section').forEach(s => s.classList.add('hidden'));
            const section = document.getElementById(targetId);
            if(section) section.classList.remove('hidden');
            document.querySelectorAll('.nav-link').forEach(l => l.classList.toggle('active', l.dataset.target === targetId));
            
            // Special handling for breath helper section to stop animation when leaving
            if (targetId !== 'breath-helper-section') { 
                stopBreathing(false); // Stop breathing animation if navigating away, don't log duration
            }
            renderContentForSection(targetId); 
        };
        
        const renderContentForSection = (sectionId) => {
            const section = document.getElementById(sectionId);
            if (!section) return;
            clearTimeout(section.renderTimeout);
            section.renderTimeout = setTimeout(() => {
                if (!hasInitialDataLoaded) return;
                switch (sectionId) {
                    case 'dashboard-section': section.innerHTML = renderDashboard(); break;
                    case 'mood-logging-section': section.innerHTML = renderMoodLoggingPage(); break;
                    case 'habit-tracking-section': section.innerHTML = renderHabitTrackingPage(); break;
                    case 'hydration-section': 
                        section.innerHTML = renderHydrationPage();
                        updateHydrationChart(); 
                        break;
                    case 'sleep-tracking-section': 
                        section.innerHTML = renderSleepTrackingPage(); 
                        break; 
                    case 'breath-helper-section':
                        section.innerHTML = renderBreathHelperPage();
                        // Initialize breathing settings inputs
                        document.getElementById('inhale-duration-input').value = inhaleDuration;
                        document.getElementById('hold-duration-input').value = holdDuration;
                        document.getElementById('exhale-duration-input').value = exhaleDuration;
                        break;
                    case 'calendar-section': section.innerHTML = renderCalendarView(currentCalendarDate); break;
                    case 'analytics-section': 
                        section.innerHTML = renderAnalyticsPage();
                        // Default to 7 days for all analytics charts
                        renderSummaryStatistics('7days'); // Render summary with default period
                        renderMoodTrendChart('7days');
                        renderHabitCompletionChart('7days');
                        renderSleepTrendChart('7days');
                        renderHydrationTrendChart('7days');
                        renderBreathTrendChart('7days');
                        break;
                    case 'recommendations-section':
                        section.innerHTML = renderRecommendationsPage();
                        // Default to '7days' analysis when entering the recommendations section
                        generatePersonalizedRecommendations('7days'); 
                        break;
                    case 'utility-section': section.innerHTML = renderUtilityPage(); break; // New
                }
            }, 50);
        };
        
        // --- HTML Template Renderers ---
        const SVG_ICONS = {
            plus: `<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>`,
            edit: `<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>`,
            trash: `<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`,
            fire: `<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5.5 2a.5.5 0 00-.5.5v1.25a.75.75 0 01-1.5 0V2.5a2 2 0 012-2h1a2 2 0 012 2v1.25a.75.75 0 01-1.5 0V2.5a.5.5 0 00-.5-.5h-1z" /><path fill-rule="evenodd" d="M8.25 6.5a.75.75 0 01.75-.75h2a.75.75 0 010 1.5h-2a.75.75 0 01-.75-.75zM3 10.5a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75zM3.75 14a.75.75 0 000 1.5h4.5a.75.75 0 000-1.5h-4.5z" clip-rule="evenodd" /></svg>`,
            archive: `<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h3" /></svg>`,
            unarchive: `<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>`
        };
        const MOOD_EMOJIS = ['ðŸ˜¡', 'ðŸ˜ ', 'ðŸ˜ž', 'ðŸ˜”', 'ðŸ˜', 'ðŸ™‚', 'ðŸ˜Š', 'ðŸ˜„', 'ðŸ˜', 'ðŸ¤©'];
        const getMoodColor = (level) => `hsl(${(level - 1) * 12 + 5}, 80%, 60%)`;

        function renderDashboard() {
            const today = new Date();
            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setDate(today.getDate() - 6);
            const recentMoods = moodLogs.filter(log => new Date(log.timestamp) >= sevenDaysAgo);
            const avgMood = recentMoods.length ? (recentMoods.reduce((sum, log) => sum + log.moodLevel, 0) / recentMoods.length).toFixed(1) : '--';
            
            let dueCount = 0, completedCount = 0;
            habits.filter(h => !h.isArchived).forEach(habit => { // Only count non-archived habits
                if(isHabitDueOn(habit, today)) {
                    dueCount++;
                    if(getHabitStatusOnDate(habit.id, toYYYYMMDD(today)) === 'completed') completedCount++;
                }
            });

            return `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-indigo-100 p-6 rounded-xl text-center">
                        <h3 class="text-xl font-semibold text-gray-700 mb-2">Last 7 Days Mood</h3>
                        <p class="text-5xl font-extrabold text-indigo-700">${avgMood}</p>
                    </div>
                     <div class="bg-green-100 p-6 rounded-xl text-center">
                        <h3 class="text-xl font-semibold text-gray-700 mb-2">Today's Habits</h3>
                        <p class="text-4xl font-extrabold"><span class="text-green-600">${completedCount}</span> / <span class="text-gray-800">${dueCount}</span></p>
                    </div>
                </div>
                <div class="mt-8"><h3 class="text-2xl font-bold text-gray-800 mb-4">Today's Habits</h3><div id="daily-habits-container" class="space-y-3">${renderDailyHabitsList()}</div></div>
                <div class="mt-8"><h3 class="text-2xl font-bold text-gray-800 mb-4">Recent Mood Logs</h3><div id="recent-moods-container" class="space-y-3">${renderMoodLogsList(5)}</div></div>
            `;
        }

        function renderMoodLoggingPage() {
            moodInsightOutput.innerHTML = '';
            moodInsightOutput.classList.add('hidden');
            journalPromptOutput.innerHTML = '';
            journalPromptOutput.classList.add('hidden');

            return `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h2 class="text-2xl font-bold mb-6">How are you feeling?</h2>
                        <div class="space-y-6">
                            <div>
                                <label for="mood-slider" class="block text-lg font-medium text-center">
                                    Overall Mood: <span id="mood-value" class="text-indigo-600 font-semibold">5</span>
                                    <span id="mood-emoji" class="text-5xl block mt-2">${MOOD_EMOJIS[4]}</span>
                                </label>
                                <input type="range" id="mood-slider" min="1" max="10" value="5" class="w-full mt-4">
                            </div>
                            <div>
                                <label for="mood-notes" class="block text-sm font-medium text-gray-700">Journal Entry</label>
                                <textarea id="mood-notes" rows="4" class="mt-1 block w-full border border-gray-300 rounded-md p-2" placeholder="What's on your mind?"></textarea>
                            </div>
                            <!-- New: Journaling Prompts -->
                            <div class="flex justify-end">
                                <button type="button" id="get-journal-prompt-btn" class="px-3 py-1 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700 text-sm flex items-center gap-1">âœ¨Get Prompt</button>
                            </div>
                            <div id="journal-prompt-container"></div>
                            <!-- New: Mood Tags -->
                            <div>
                                <label for="mood-tags" class="block text-sm font-medium text-gray-700">Tags (comma-separated)</label>
                                <input type="text" id="mood-tags" class="mt-1 block w-full border border-gray-300 rounded-md p-2" placeholder="e.g., work, stress, family, joy">
                            </div>

                            <button id="log-mood-btn" class="w-full bg-indigo-600 text-white font-semibold py-3 rounded-lg hover:bg-indigo-700">Log Mood</button>
                            <button id="get-mood-insight-btn" class="w-full bg-blue-600 text-white font-semibold py-3 rounded-lg hover:bg-blue-700 mt-2">âœ¨Get Journal Insight</button>
                            <div id="mood-insight-container"></div>
                        </div>
                    </div>
                    <div><h2 class="text-2xl font-bold mb-6">Mood History</h2><div id="mood-log-list-full" class="space-y-3 max-h-[60vh] overflow-y-auto no-scrollbar">${renderMoodLogsList()}</div></div>
                </div>`;
        }
        
        function renderMoodLogsList(limit = 0) {
            if (moodLogs.length === 0) return `<p class="text-gray-500 text-center py-4">No moods logged yet.</p>`;
            const sortedMoods = [...moodLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const toRender = limit > 0 ? sortedMoods.slice(0, limit) : sortedMoods;
            return toRender.map(log => {
                const moodColor = getMoodColor(log.moodLevel);
                const textColor = getTextColorForBackground(moodColor);
                return `
                    <div class="p-4 rounded-lg flex items-center gap-4" style="background-color: ${moodColor}; color: ${textColor};">
                        <span class="text-4xl">${MOOD_EMOJIS[log.moodLevel - 1]}</span>
                        <div class="flex-grow">
                            <p class="font-bold">Mood: ${log.moodLevel}/10</p>
                            <p class="text-sm opacity-90">${formatDateTime(log.timestamp)}</p>
                            ${log.notes ? `<p class="text-sm mt-1 italic">"${log.notes}"</p>` : ''}
                            ${log.tags && log.tags.length > 0 ? `<p class="text-xs mt-1 opacity-80">Tags: ${log.tags.join(', ')}</p>` : ''}
                        </div>
                        <button class="delete-mood-btn p-2 hover:bg-black/20 rounded-full" data-id="${log.id}">${SVG_ICONS.trash}</button>
                    </div>`;
            }).join('');
        }

        function renderHabitTrackingPage() {
            const showArchived = localStorage.getItem('showArchivedHabits') === 'true';
            const filteredHabits = habits.filter(h => showArchived ? true : !h.isArchived);

            return `
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold">Your Habits</h2>
                    <div class="flex items-center gap-3">
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="toggle-archived-habits" class="form-checkbox text-indigo-600" ${showArchived ? 'checked' : ''}>
                            <span class="ml-2 text-gray-700 text-sm">Show Archived</span>
                        </label>
                        <button id="add-new-habit-btn" class="flex items-center gap-2 bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700">
                            ${SVG_ICONS.plus}<span>Add Habit</span>
                        </button>
                    </div>
                </div>
                <div id="habits-list-container" class="space-y-4">${renderHabitsList(filteredHabits)}</div>`;
        }

        function renderHabitsList(habitsToRender) {
            if(habitsToRender.length === 0) return `<p class="text-gray-500 text-center py-8">No habits yet. Click 'Add Habit' to start!'</p>`;
            const sortedHabits = [...habitsToRender].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            return sortedHabits.map(habit => {
                const goalInfo = habit.goalType && habit.goalValue ? `Goal: ${habit.goalValue} ${habit.goalUnit || habit.goalType}` : '';
                return `
                    <div class="rounded-lg p-4 flex items-center gap-4 ${getTextColorForBackground(habit.color)}" style="background-color: ${habit.color};">
                        <div class="flex-grow">
                            <p class="font-bold text-lg">${habit.name} ${habit.isArchived ? '<span class="text-sm italic opacity-80">(Archived)</span>' : ''}</p>
                            <p class="text-sm opacity-90">${habit.frequency === 'daily' ? 'Daily' : `On: ${habit.days.join(', ')}`}</p>
                            ${habit.habitReminderTime ? `<p class="text-xs opacity-80">Reminder: ${habit.habitReminderTime}</p>` : ''}
                            ${goalInfo ? `<p class="text-xs opacity-80">${goalInfo}</p>` : ''}
                        </div>
                        <div class="flex items-center gap-2 text-orange-400 font-bold">
                            ${SVG_ICONS.fire} <span>${habitStreaks[habit.id] || 0}</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="edit-habit-btn p-2 rounded-full hover:bg-black/20" data-id="${habit.id}">${SVG_ICONS.edit}</button>
                            <button class="archive-toggle-habit-btn p-2 rounded-full hover:bg-black/20" data-id="${habit.id}" data-archived="${habit.isArchived ? 'true' : 'false'}">
                                ${habit.isArchived ? SVG_ICONS.unarchive : SVG_ICONS.archive}
                            </button>
                            <button class="delete-habit-btn p-2 rounded-full hover:bg-black/20" data-id="${habit.id}">${SVG_ICONS.trash}</button>
                        </div>
                    </div>`;
            }).join('');
        }
        
        function renderDailyHabitsList() {
            const today = new Date();
            const habitsDue = habits.filter(h => !h.isArchived && isHabitDueOn(h, today)); // Only show non-archived habits due today
            if(habitsDue.length === 0) return `<p class="text-gray-500 text-center py-4">No habits due today.</p>`;
            return habitsDue.map(habit => {
                const status = getHabitStatusOnDate(habit.id, toYYYYMMDD(today));
                return `
                    <div class="p-3 rounded-lg flex items-center gap-4 border border-gray-200">
                        <div class="w-3 h-3 rounded-full" style="background-color:${habit.color};"></div>
                        <p class="flex-grow font-semibold">${habit.name}</p>
                        <div class="flex gap-1">
                            <button class="habit-status-btn px-3 py-1 text-sm rounded-md ${status === 'completed' ? 'bg-green-500 text-white' : 'bg-gray-200'}" data-habit-id="${habit.id}" data-status="completed">Done</button>
                            <button class="habit-status-btn px-3 py-1 text-sm rounded-md ${status === 'skipped' ? 'bg-yellow-500 text-white' : 'bg-gray-200'}" data-habit-id="${habit.id}" data-status="skipped">Skip</button>
                        </div>
                    </div>`;
            }).join('');
        }

        function renderHydrationPage() {
            const percentage = dailyWaterNeed > 0 ? ((dailyIntake / dailyWaterNeed) * 100).toFixed(0) : 0;
            const statusColor = percentage >= 100 ? 'text-green-600' : 'text-orange-500';

            return `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <!-- Water Need Calculation Section -->
                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h2 class="text-2xl font-bold mb-6">Calculate Daily Water Need</h2>
                        <form id="water-need-form" class="space-y-4">
                            <div>
                                <label for="user-age" class="block text-sm font-medium text-gray-700">Age (years)</label>
                                <input type="number" id="user-age" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="e.g., 30" min="1" max="120">
                            </div>
                            <div>
                                <label for="user-weight" class="block text-sm font-medium text-gray-700">Weight (kg)</label>
                                <input type="number" id="user-weight" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="e.g., 70" min="10" max="300">
                            </div>
                            <div>
                                <label for="activity-level" class="block text-sm font-medium text-gray-700">Activity Level</label>
                                <select id="activity-level" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                                    <option value="sedentary">Sedentary (little to no exercise)</option>
                                    <option value="lightly_active">Lightly Active (light exercise/sports 1-3 days/week)</option>
                                    <option value="moderately_active">Moderately Active (moderate exercise/sports 3-5 days/week)</option>
                                    <option value="very_active">Very Active (hard exercise/sports 6-7 days/week)</option>
                                    <option value="extra_active">Extra Active (very hard exercise/physical job)</option>
                                </select>
                            </div>
                            <div>
                                <label for="climate" class="block text-sm font-medium text-gray-700">Climate</label>
                                <select id="climate" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                                    <option value="temperate">Temperate</option>
                                    <option value="hot_humid">Hot & Humid</option>
                                    <option value="hot_dry">Hot & Dry</option>
                                    <option value="cold">Cold</option>
                                </select>
                            </div>
                            <button type="button" id="calculate-water-need-btn" class="w-full bg-indigo-600 text-white font-semibold py-3 rounded-lg hover:bg-indigo-700">Calculate My Water Need</button>
                            <div id="water-need-output" class="bg-blue-100 text-blue-800 p-3 rounded-md mt-4 hidden"></div>
                        </form>
                    </div>

                    <!-- Water Intake Tracking Section -->
                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h2 class="2xl font-bold mb-6">Today's Hydration</h2>
                        <div class="text-center mb-6">
                            <p class="text-xl font-semibold text-gray-700">Daily Goal: <span id="display-water-need" class="text-indigo-600">${dailyWaterNeed} ml</span></p>
                            <p class="text-sm text-gray-500 italic mb-2">AI-generated estimate. Consult a medical professional for personalized advice.</p>
                            <p class="text-xl font-semibold text-gray-700">Current Intake: <span id="display-current-intake" class="text-green-600">${dailyIntake} ml</span></p>
                            <p class="text-lg font-semibold ${statusColor}" id="hydration-percentage-text">${percentage}% fulfilled</p>
                        </div>
                        <div class="relative h-64 w-64 mx-auto mb-6">
                            <canvas id="hydration-chart"></canvas>
                        </div>
                        <div class="space-y-4">
                            ${Object.keys(BEVERAGE_WATER_EQUIVALENT).map(type => `
                                <div class="flex items-center gap-2">
                                    <label for="log-${type}-qty" class="capitalize flex-grow text-sm font-medium text-gray-700">${type.replace('-', ' ')} (ml)</label>
                                    <input type="number" id="log-${type}-qty" class="w-24 border border-gray-300 rounded-md shadow-sm p-2" value="250" min="1">
                                    <button class="log-drink-btn px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600" data-drink-type="${type}">Log</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderSleepTrackingPage() {
            return `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h2 class="text-2xl font-bold mb-6">Log Your Sleep</h2>
                        <div class="space-y-6">
                            <div>
                                <label for="sleep-date" class="block text-sm font-medium text-gray-700">Date</label>
                                <input type="date" id="sleep-date" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" value="${toYYYYMMDD(new Date())}">
                            </div>
                            <div class="flex gap-4">
                                <div class="flex-1">
                                    <label for="sleep-hours" class="block text-sm font-medium text-gray-700">Hours</label>
                                    <input type="number" id="sleep-hours" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" min="0" max="24" value="8">
                                </div>
                                <div class="flex-1">
                                    <label for="sleep-minutes" class="block text-sm font-medium text-gray-700">Minutes</label>
                                    <input type="number" id="sleep-minutes" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" min="0" max="59" value="0">
                                </div>
                            </div>
                            <!-- New: Sleep Quality Rating -->
                            <div>
                                <label for="sleep-quality-slider" class="block text-sm font-medium text-gray-700">Sleep Quality: <span id="sleep-quality-value" class="font-semibold text-indigo-600">3</span>/5</label>
                                <input type="range" id="sleep-quality-slider" min="1" max="5" value="3" class="w-full mt-1">
                            </div>
                            <div>
                                <label for="sleep-abnormalities" class="block text-sm font-medium text-gray-700">Sleep Abnormalities / Notes</label>
                                <textarea id="sleep-abnormalities" rows="4" class="mt-1 block w-full border border-gray-300 rounded-md p-2" placeholder="e.g., Woke up twice, had vivid dreams"></textarea>
                            </div>
                            <button id="log-sleep-btn" class="w-full bg-indigo-600 text-white font-semibold py-3 rounded-lg hover:bg-indigo-700">Log Sleep</button>
                            <div id="sleep-logging-status" class="bg-blue-100 text-blue-800 p-3 rounded-md mt-4 hidden"></div>
                        </div>
                    </div>
                    <div><h2 class="text-2xl font-bold mb-6">Sleep History</h2><div id="sleep-log-list" class="space-y-3 max-h-[60vh] overflow-y-auto no-scrollbar">${renderSleepLogsList()}</div></div>
                </div>`;
        }

        function renderSleepLogsList() {
            if (sleepLogs.length === 0) return `<p class="text-gray-500 text-center py-4">No sleep logs yet.</p>`;
            const sortedSleeps = [...sleepLogs].sort((a, b) => new Date(b.date) - new Date(a.date));
            return sortedSleeps.map(log => `
                <div class="p-4 rounded-lg bg-white shadow-sm border border-gray-200">
                    <div class="flex justify-between items-center mb-2">
                        <p class="font-bold text-lg">${toYYYYMMDD(log.date)}</p>
                        <button class="delete-sleep-log-btn text-gray-400 hover:text-gray-600" data-id="${log.id}">${SVG_ICONS.trash}</button>
                    </div>
                    <p class="text-gray-700">Duration: ${log.duration} hours</p>
                    <p class="text-gray-700">Quality: ${log.sleepQuality || 'N/A'}/5 Stars</p>
                    ${log.abnormalities ? `<p class="text-sm italic text-gray-600 mt-1">Notes: "${log.abnormalities}"</p>` : ''}
                    ${log.analysis ? `<div class="bg-blue-50 text-blue-800 p-2 text-sm rounded-md mt-2">AI Analysis: ${marked.parse(log.analysis || '')}</div>` : ''}
                    ${log.analysis === null && log.abnormalities ? `<div id="sleep-analysis-loading-${log.id}" class="bg-yellow-100 text-yellow-800 p-2 text-sm rounded-md mt-2 loading-text">Generating analysis...</div>` : ''}
                </div>`).join('');
        }


        function renderBreathHelperPage() {
            return `
                <div class="flex flex-col items-center justify-center p-6 bg-gray-50 rounded-xl max-w-lg mx-auto shadow-md">
                    <h2 class="text-2xl font-bold text-center mb-6">Guided Breathing</h2>
                    <div id="breathing-circle" class="breathing-circle-container">
                        <span id="breathing-text" class="breathing-text">Start</span>
                    </div>
                    <div class="flex flex-wrap justify-center gap-4 mt-6 w-full">
                        <div class="flex-1 min-w-[100px] max-w-[150px]">
                            <label for="inhale-duration-input" class="block text-sm font-medium text-gray-700">Inhale (s)</label>
                            <input type="number" id="inhale-duration-input" min="1" value="4" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 text-center">
                        </div>
                        <div class="flex-1 min-w-[100px] max-w-[150px]">
                            <label for="hold-duration-input" class="block text-sm font-medium text-gray-700">Hold (s)</label>
                            <input type="number" id="hold-duration-input" min="0" value="4" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 text-center">
                        </div>
                        <div class="flex-1 min-w-[100px] max-w-[150px]">
                            <label for="exhale-duration-input" class="block text-sm font-medium text-gray-700">Exhale (s)</label>
                            <input type="number" id="exhale-duration-input" min="1" value="4" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 text-center">
                        </div>
                    </div>
                    <div class="mt-6 flex gap-4">
                        <button id="start-breathing-btn" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700">Start Breathing</button>
                        <button id="stop-breathing-btn" class="px-6 py-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600">Stop</button>
                        <button id="log-breathing-session-btn" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700">Log Session</button>
                    </div>
                    <div class="mt-8 w-full">
                        <h3 class="text-xl font-semibold mb-4 text-gray-800 text-center">Breathing Session History</h3>
                        <div id="breathing-log-list" class="space-y-3 max-h-[40vh] overflow-y-auto no-scrollbar">
                            ${renderBreathLogsList()}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderBreathLogsList() {
            if (breathLogs.length === 0) return `<p class="text-gray-500 text-center py-4">No breathing sessions logged yet.</p>`;
            const sortedLogs = [...breathLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return sortedLogs.map(log => `
                <div class="p-3 rounded-lg bg-white shadow-sm border border-gray-200 flex justify-between items-center">
                    <div>
                        <p class="font-semibold">${formatDateTime(log.timestamp)}</p>
                        <p class="text-sm text-gray-600">Pattern: Inhale ${log.inhaleDuration}s, Hold ${log.holdDuration}s, Exhale ${log.exhaleDuration}s</p>
                        <p class="text-sm text-gray-600">Total Session Duration: ${log.elapsedTime ? (log.elapsedTime / 60).toFixed(1) : 'N/A'} minutes</p> <!-- Changed to minutes here -->
                    </div>
                    <button class="delete-breath-log-btn text-gray-400 hover:text-gray-600" data-id="${log.id}">${SVG_ICONS.trash}</button>
                </div>
            `).join('');
        }

        function renderCalendarView(date) {
            const month = date.getMonth(), year = date.getFullYear();
            const firstDay = new Date(year, month, 1), lastDay = new Date(year, month + 1, 0);
            let dayCells = Array(firstDay.getDay()).fill('<div class="calendar-day border border-gray-200 bg-gray-50"></div>').join('');

            for (let i = 1; i <= lastDay.getDate(); i++) {
                const dayDate = new Date(year, month, i), dateKey = toYYYYMMDD(dayDate);
                const moodsToday = moodLogs.filter(log => toYYYYMMDD(new Date(log.timestamp)) === dateKey);
                const avgMood = moodsToday.length ? moodsToday.reduce((s, l) => s + l.moodLevel, 0) / moodsToday.length : null;
                // Filter habits for calendar view: only non-archived habits
                let habitDots = habits.filter(h => !h.isArchived).map(h => dailyHabitStatuses[h.id]?.[dateKey] === 'completed' ? `<div class="w-2 h-2 rounded-full" style="background-color:${h.color}" title="${h.name}"></div>` : '').join('');
                
                let moodIndicator = '';
                if(avgMood) {
                    moodIndicator = `
                        <span class="2xl" title="Avg Mood: ${avgMood.toFixed(1)}">
                            ${MOOD_EMOJIS[Math.round(avgMood) - 1]}
                        </span>
                    `;
                }

                dayCells += `
                    <div class="calendar-day border border-gray-200 p-2 ${toYYYYMMDD(new Date()) === dateKey ? 'calendar-day-today' : ''}" style="${avgMood ? `background-color: ${getMoodColor(avgMood)}` : ''}">
                        <div class="flex justify-between items-start">
                            <div class="font-semibold ${avgMood ? getTextColorForBackground(getMoodColor(avgMood)) : ''}">${i}</div>
                            ${moodIndicator}
                        </div>
                        <div class="flex flex-wrap gap-1 mt-2">${habitDots}</div>
                    </div>`;
            }

            return `
                <div class="bg-white p-4 sm:p-6 rounded-xl">
                    <div class="flex justify-between items-center mb-4">
                        <button class="calendar-nav-btn px-3 py-1 rounded bg-gray-200" data-direction="-1">&lt; Prev</button>
                        <h2 class="text-xl font-bold">${date.toLocaleString('default', { month: 'long', year: 'numeric' })}</h2>
                        <button class="calendar-nav-btn px-3 py-1 rounded bg-gray-200" data-direction="1">Next &gt;</button>
                    </div>
                    <div class="calendar-grid text-center font-semibold text-gray-600 mb-2">
                        ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(d => `<div>${d}</div>`).join('')}
                    </div>
                    <div class="calendar-grid">${dayCells}</div>
                </div>`;
        }

        function renderAnalyticsPage() {
            const periods = [
                { value: '7days', label: '7 Days' },
                { value: '30days', label: '30 Days' },
                { value: '90days', label: '90 Days' },
                { value: '180days', label: '180 Days' },
                { value: '360days', label: '360 Days' },
                { value: 'alldays', label: 'All Time' }
            ];

            const renderFilterButtons = (chartType, initialActivePeriod = '7days') => `
                <div class="flex flex-wrap justify-center gap-2 mb-4">
                    ${periods.map(p => `
                        <button class="analytics-filter-btn px-3 py-1 rounded bg-gray-200 ${p.value === initialActivePeriod ? 'active' : ''}" data-chart="${chartType}" data-period="${p.value}">${p.label}</button>
                    `).join('')}
                </div>
            `;

            return `
                <div class="space-y-8">
                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h3 class="text-xl font-semibold mb-4 text-center">Summary Statistics</h3>
                        ${renderFilterButtons('summary', '7days')}
                        <div id="summary-statistics-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- Summary stats will be rendered here by renderSummaryStatistics -->
                        </div>
                    </div>

                    <div class="bg-gray-50 p-6 rounded-xl">
                        <h3 class="text-xl font-semibold mb-4 text-center">Mood & Habit Insights</h3>
                        ${renderFilterButtons('correlation-insights', '7days')}
                        <div id="insights-container">${renderCorrelationInsights('7days')}</div>
                    </div>

                    <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                        <div class="bg-white p-6 rounded-xl shadow-md">
                            <h3 class="text-xl font-semibold mb-4 text-center">Mood Trend</h3>
                            ${renderFilterButtons('mood')}
                            <div class="relative h-80"><canvas id="mood-trend-chart"></canvas></div>
                        </div>
                        <div class="bg-white p-6 rounded-xl shadow-md">
                            <h3 class="text-xl font-semibold mb-4 text-center">Habit Completion</h3>
                            ${renderFilterButtons('habit')}
                            <div class="relative h-80"><canvas id="habit-completion-chart"></canvas></div>
                        </div>
                        <div class="bg-white p-6 rounded-xl shadow-md">
                            <h3 class="text-xl font-semibold mb-4 text-center">Sleep Duration</h3>
                            ${renderFilterButtons('sleep')}
                            <div class="relative h-80"><canvas id="sleep-trend-chart"></canvas></div>
                        </div>
                        <div class="bg-white p-6 rounded-xl shadow-md">
                            <h3 class="text-xl font-semibold mb-4 text-center">Hydration Intake</h3>
                            ${renderFilterButtons('hydration')}
                            <div class="relative h-80"><canvas id="hydration-analytics-chart"></canvas></div>
                        </div>
                        <div class="bg-white p-6 rounded-xl shadow-md">
                            <h3 class="text-xl font-semibold mb-4 text-center">Breathing Sessions</h3>
                            ${renderFilterButtons('breath')}
                            <div class="relative h-80"><canvas id="breath-trend-chart"></canvas></div>
                        </div>
                    </div>
                </div>`;
        }

        function renderRecommendationsPage() {
            return `
                <div class="bg-gray-50 p-6 rounded-xl">
                    <h2 class="text-2xl font-bold mb-6 text-center">Personalized Recommendations</h2>
                    <div class="flex flex-wrap justify-center gap-2 mb-4" id="recommendations-filter-buttons">
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="today">Today</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="3days">Last 3 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200 active" data-period="7days">Last 7 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="30days">Last 30 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="90days">Last 90 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="180days">Last 180 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="360days">Last 360 Days</button>
                        <button class="recommendation-filter-btn px-3 py-1 rounded bg-gray-200" data-period="alldays">All Time</button>
                    </div>
                    <div id="recommendations-output" class="bg-blue-100 text-blue-800 p-4 rounded-md hidden loading-text">
                        Generating recommendations based on your data...
                    </div>
                    <div id="recommendations-content" class="space-y-4 mt-4">
                        <p class="text-gray-600 text-center">Select a period or click 'Generate Recommendations' to get personalized insights.</p>
                    </div>
                     <div class="flex justify-center mt-6">
                        <button id="generate-recommendations-btn" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700">
                            âœ¨ Regenerate Recommendations
                        </button>
                    </div>
                </div>
            `;
        }

        // New: Utility Page for Export/Import
        function renderUtilityPage() {
            return `
                <div class="bg-gray-50 p-6 rounded-xl max-w-xl mx-auto shadow-md">
                    <h2 class="text-2xl font-bold mb-6 text-center">Data Management</h2>
                    <div class="space-y-4">
                        <div class="flex flex-col gap-2">
                            <label for="import-file-input" class="block text-sm font-medium text-gray-700">Import Data from JSON File</label>
                            <input type="file" id="import-file-input" accept=".json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
                            <button id="import-data-btn" class="w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Import Data</button>
                            <div id="import-status" class="text-sm mt-2 hidden"></div>
                        </div>
                        <div class="border-t border-gray-200 pt-4 mt-4 flex flex-col gap-2">
                            <h3 class="block text-sm font-medium text-gray-700">Export All Data to JSON</h3>
                            <button id="export-data-btn" class="w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">Export Data</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // --- Data Handling & Business Logic ---

        // Helper for robust date parsing and validation
        const parseAndValidateDate = (dateString, fieldName, errorMessages) => {
            if (typeof dateString !== 'string' || !dateString) {
                errorMessages.push(`Invalid ${fieldName}: must be a non-empty string.`);
                return null;
            }
            const date = new Date(dateString);
            if (isNaN(date.getTime())) {
                errorMessages.push(`Invalid ${fieldName}: "${dateString}" is not a valid date format.`);
                return null;
            }
            return date;
        };

        // Helper for robust number parsing and validation
        const parseAndValidateNumber = (value, fieldName, errorMessages, min = -Infinity, max = Infinity) => {
            if (typeof value === 'string') value = parseFloat(value);
            if (typeof value !== 'number' || isNaN(value)) {
                errorMessages.push(`Invalid ${fieldName}: must be a number.`);
                return null;
            }
            if (value < min || value > max) {
                errorMessages.push(`Invalid ${fieldName}: value ${value} is out of range (${min}-${max}).`);
                return null;
            }
            return value;
        };


        const getHabitStatusOnDate = (habitId, dateKey) => dailyHabitStatuses[habitId]?.[dateKey] || 'pending';
        const isHabitDueOn = (habit, date) => {
            const dateKey = toYYYYMMDD(date);
            // Don't show archived habits as "due" in the normal flow
            if (habit.isArchived) return false; 
            if ((habit.startDate && dateKey < habit.startDate) || (habit.endDate && dateKey > habit.endDate)) return false;
            if (habit.frequency === 'daily') return true;
            return habit.days.includes(date.toLocaleDateString('en-US', { weekday: 'short' }));
        };
        const calculateHabitStreaks = () => {
            habits.filter(h => !h.isArchived).forEach(habit => { // Only calculate for non-archived habits
                let currentStreak = 0;
                let date = new Date();
                while (true) {
                    if (!isHabitDueOn(habit, date)) {
                        date.setDate(date.getDate() - 1);
                        continue;
                    }
                    if (getHabitStatusOnDate(habit.id, toYYYYMMDD(date)) === 'completed') {
                        currentStreak++;
                        date.setDate(date.getDate() - 1);
                    } else {
                        break;
                    }
                }
                habitStreaks[habit.id] = currentStreak;
            });
        };

        function renderCorrelationInsights(period = '7days') {
            const { filteredMoodLogs, filteredHabitsWithStatus, filteredSleepLogs } = getFilteredDataByPeriod(period);

            // Filter out archived habits before analysis
            const nonArchivedHabits = habits.filter(h => !h.isArchived);

            if (filteredHabitsWithStatus.length === 0 || filteredMoodLogs.length === 0) {
                return '<p class="text-center text-gray-500">Log more data for correlation insights.</p>';
            }

            const insights = [];

            // Mood and Habit correlation
            nonArchivedHabits.forEach(habit => { // Iterate over non-archived habits
                const moodsCompleted = [], moodsNotCompleted = [];
                const habitDates = filteredHabitsWithStatus.filter(item => item.habitId === habit.id);

                habitDates.forEach(habitStatus => {
                    const moodForDate = filteredMoodLogs.find(log => toYYYYMMDD(log.timestamp) === habitStatus.date);
                    if (moodForDate) {
                        if (habitStatus.status === 'completed') {
                            moodsCompleted.push(moodForDate.moodLevel);
                        } else if (habitStatus.status === 'skipped') {
                            moodsNotCompleted.push(moodForDate.moodLevel);
                        }
                    }
                });

                if (moodsCompleted.length > 0) {
                    const avgCompleted = moodsCompleted.reduce((a, b) => a + b, 0) / moodsCompleted.length;
                    let insightText = `When you **${habit.name}**, your average mood is **${avgCompleted.toFixed(1)}**/10.`;
                    
                    if (moodsNotCompleted.length > 0) {
                        const avgNotCompleted = moodsNotCompleted.reduce((a, b) => a + b, 0) / moodsNotCompleted.length;
                        if (Math.abs(avgCompleted - avgNotCompleted) > 0.5) { // Threshold for significant difference
                            insightText += ` This is **${Math.abs(avgCompleted - avgNotCompleted).toFixed(1)}** points ${avgCompleted > avgNotCompleted ? 'higher' : 'lower'} than when you didn't complete it.`;
                        }
                    }
                    insights.push(insightText);
                }
            });

            // Mood and Sleep correlation
            if (filteredSleepLogs.length > 0 && filteredMoodLogs.length > 0) {
                const moodAfterGoodSleep = [];
                const moodAfterPoorSleep = [];

                filteredSleepLogs.forEach(sleepLog => {
                    const moodOnDayAfterSleep = filteredMoodLogs.find(mood => {
                        const sleepDate = new Date(sleepLog.date);
                        const moodDate = new Date(mood.timestamp);
                        // Check if mood log is on the day immediately following the sleep log
                        const dayAfterSleep = new Date(sleepDate);
                        dayAfterSleep.setDate(sleepDate.getDate() + 1);
                        return toYYYYMMDD(moodDate) === toYYYYMMDD(dayAfterSleep);
                    });

                    if (moodOnDayAfterSleep) {
                        if (sleepLog.duration >= 7) { // Assuming 7+ hours is "good" sleep
                            moodAfterGoodSleep.push(moodOnDayAfterSleep.moodLevel);
                        } else { // Less than 7 hours is "poor" sleep
                            moodAfterPoorSleep.push(moodOnDayAfterSleep.moodLevel);
                        }
                    }
                });

                if (moodAfterGoodSleep.length > 0) {
                    const avgMoodGoodSleep = moodAfterGoodSleep.reduce((a, b) => a + b, 0) / moodAfterGoodSleep.length;
                    let insightText = `On days following good sleep (7+ hours), your average mood is **${avgMoodGoodSleep.toFixed(1)}**/10.`;
                    
                    if (moodAfterPoorSleep.length > 0) {
                        const avgMoodPoorSleep = moodsNotCompleted.reduce((a, b) => a + b, 0) / moodAfterPoorSleep.length;
                        if (Math.abs(avgMoodGoodSleep - avgMoodPoorSleep) > 0.5) {
                            insightText += ` This is **${Math.abs(avgMoodGoodSleep - avgMoodPoorSleep).toFixed(1)}** points ${avgMoodGoodSleep > avgMoodPoorSleep ? 'higher' : 'lower'} than after poor sleep.`;
                        }
                    }
                    insights.push(insightText);
                }
            }


            return insights.length ? `<div class="space-y-3">${insights.map(i => `<div class="p-4 bg-white rounded-lg shadow-sm">${marked.parse(i)}</div>`).join('')}</div>` : '<p class="text-center text-gray-500">Not enough data for correlations in this period.</p>';
        }


        async function handleLogMood() {
            console.log("Attempting to log mood...");
            const moodLevel = parseInt(document.getElementById('mood-slider').value);
            const notes = document.getElementById('mood-notes').value.trim();
            const tagsInput = document.getElementById('mood-tags').value.trim();
            const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

            moodLogs.push({ id: generateUniqueId(), moodLevel, notes, tags, timestamp: new Date().toISOString() }); 
            saveData();
            document.getElementById('mood-slider').value = 5;
            document.getElementById('mood-notes').value = '';
            document.getElementById('mood-tags').value = ''; // Clear tags input
            moodInsightOutput.innerHTML = '';
            moodInsightOutput.classList.add('hidden');
            journalPromptOutput.innerHTML = '';
            journalPromptOutput.classList.add('hidden');
            renderContentForSection('mood-logging-section'); 
            renderContentForSection('dashboard-section'); 
            console.log("Mood logged:", moodLogs[moodLogs.length - 1]);
        }

        function openHabitModal(habit = null) {
            const form = document.getElementById('habit-form');
            form.reset();
            document.getElementById('specific-days-container').classList.remove('expanded');
            habitSuggestionsOutput.innerHTML = ''; 
            habitSuggestionsOutput.classList.add('hidden');
            habitSuggestionsOutput.classList.remove('loading-text'); 
            
            // Clear goal fields
            document.getElementById('habit-goal-type').value = '';
            document.getElementById('habit-goal-value').value = '';
            document.getElementById('habit-goal-unit').value = '';

            if (habit) {
                document.getElementById('habit-modal-title').textContent = 'Edit Habit';
                form.querySelector('#habit-id').value = habit.id;
                form.querySelector('#new-habit-name').value = habit.name;
                form.querySelector('#habit-frequency').value = habit.frequency;
                form.querySelector('#habit-start-date').value = habit.startDate || '';
                form.querySelector('#habit-end-date').value = habit.endDate || '';
                form.querySelector('#habit-color-picker').value = habit.color;
                form.querySelector('#habit-reminder-time').value = habit.habitReminderTime || ''; 
                if (habit.frequency === 'specific-days') {
                    document.getElementById('specific-days-container').classList.add('expanded');
                    document.querySelectorAll('#specific-days-container input').forEach(cb => cb.checked = habit.days.includes(cb.value));
                }
                // Populate goal fields
                document.getElementById('habit-goal-type').value = habit.goalType || '';
                document.getElementById('habit-goal-value').value = habit.goalValue || '';
                document.getElementById('habit-goal-unit').value = habit.goalUnit || '';

            } else {
                document.getElementById('habit-modal-title').textContent = 'Add New Habit';
                form.querySelector('#habit-color-picker').value = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
                form.querySelector('#habit-reminder-time').value = ''; 
            }
            toggleModal(habitModal, true);
        }

        async function handleHabitFormSubmit(e) {
            e.preventDefault();
            console.log("Habit form submitted.");
            const id = e.target.querySelector('#habit-id').value;
            const habitData = {
                name: e.target.querySelector('#new-habit-name').value.trim(),
                frequency: e.target.querySelector('#habit-frequency').value,
                days: Array.from(e.target.querySelectorAll('#specific-days-container input:checked')).map(cb => cb.value),
                startDate: e.target.querySelector('#habit-start-date').value || null,
                endDate: e.target.querySelector('#habit-end-date').value || null,
                color: e.target.querySelector('#habit-color-picker').value,
                habitReminderTime: e.target.querySelector('#habit-reminder-time').value || null, 
                createdAt: new Date().toISOString(),
                isArchived: false, // Default to not archived for new habits

                // New: Habit Goals
                goalType: e.target.querySelector('#habit-goal-type').value || null,
                goalValue: parseInt(e.target.querySelector('#habit-goal-value').value) || null,
                goalUnit: e.target.querySelector('#habit-goal-unit').value.trim() || null,
            };
            if(!habitData.name) {
                console.warn("Habit name is empty. Not saving.");
                return;
            }

            if (id) {
                const index = habits.findIndex(h => h.id === id);
                if (index !== -1) {
                    habits[index] = { ...habits[index], ...habitData };
                    console.log("Habit updated:", habits[index]);
                }
            } else {
                const newHabit = { id: generateUniqueId(), ...habitData };
                habits.push(newHabit);
                console.log("New habit added:", newHabit);
            }
            saveData();
            toggleModal(habitModal, false);
            renderContentForSection('habit-tracking-section'); 
            renderContentForSection('dashboard-section'); 
        }
        
        async function deleteHabit(id) {
            showConfirmation('Delete Habit?', 'This will permanently delete the habit and all its history. Are you sure?', () => {
                habits = habits.filter(h => h.id !== id);
                delete dailyHabitStatuses[id]; 
                saveData();
                renderContentForSection('habit-tracking-section');
                renderContentForSection('dashboard-section');
                renderContentForSection('calendar-section');
                renderContentForSection('analytics-section');
            });
        }

        async function archiveHabit(id) {
            const habit = habits.find(h => h.id === id);
            if (habit) {
                const newArchivedState = !habit.isArchived;
                showConfirmation(
                    newArchivedState ? 'Archive Habit?' : 'Unarchive Habit?',
                    newArchivedState ? 'This habit will be hidden from the main view but its data will be preserved for analytics.' : 'This habit will be visible again in the main view.',
                    () => {
                        habit.isArchived = newArchivedState;
                        saveData();
                        renderContentForSection('habit-tracking-section');
                        renderContentForSection('dashboard-section'); // Dashboard also hides archived habits
                    }
                );
            }
        }

        async function handleHabitStatusUpdate(habitId, status) {
            console.log(`Updating status for habit ${habitId} to ${status}`);
            const todayKey = toYYYYMMDD(new Date());
            if (!dailyHabitStatuses[habitId]) {
                dailyHabitStatuses[habitId] = {};
            }
            dailyHabitStatuses[habitId][todayKey] = (dailyHabitStatuses[habitId][todayKey] === status) ? 'pending' : status;
            saveData();
            
            if (dailyHabitStatuses[habitId][todayKey] === 'completed') {
                const habit = habits.find(h => h.id === habitId);
                if (habit) showHabitNotification(habit.name);
            }
            renderContentForSection('dashboard-section'); 
            renderContentForSection('habit-tracking-section'); // Re-render habit list to update status
            console.log("Daily habit statuses:", dailyHabitStatuses);
        }
        
        // --- Charting ---
        function renderChart(canvasId, type, period) {
            let chartInstance;
            switch(canvasId) {
                case 'mood-trend-chart': chartInstance = moodChartInstance; break;
                case 'habit-completion-chart': chartInstance = habitChartInstance; break;
                case 'sleep-trend-chart': chartInstance = sleepChartInstance; break;
                case 'hydration-analytics-chart': chartInstance = hydrationChartInstance; break;
                case 'breath-trend-chart': chartInstance = breathChartInstance; break;
            }
            if (chartInstance) chartInstance.destroy();
            
            const canvas = document.getElementById(canvasId);
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const { labels, datasets, noData } = getChartData(period, type);
            
            const noDataP = canvas.parentElement.querySelector('.chart-no-data');
            if (noData) {
                if(!noDataP) {
                    const p = document.createElement('p');
                    p.className = 'chart-no-data absolute inset-0 flex items-center justify-center text-gray-500';
                    p.textContent = 'No data for this period.';
                    canvas.parentElement.appendChild(p);
                }
                return;
            } else if(noDataP) {
                 noDataP.remove();
            }

            const chartConfig = {
                type: (type === 'mood' || type === 'sleep' || type === 'hydration-total' || type === 'breath') ? 'line' : 'bar',
                data: { labels, datasets: Object.values(datasets) },
                options: { responsive: true, maintainAspectRatio: false }
            };

            if(type === 'mood') {
                chartConfig.options.scales = { y: { min: 1, max: 10 } };
                moodChartInstance = new Chart(ctx, chartConfig);
            } else if (type === 'habit') {
                chartConfig.options.scales = { x: { stacked: true }, y: { stacked: true, beginAtZero: true } };
                habitChartInstance = new Chart(ctx, chartConfig);
            } else if (type === 'sleep') {
                 chartConfig.options.scales = { y: { beginAtZero: true, title: { display: true, text: 'Hours' } } };
                 sleepChartInstance = new Chart(ctx, chartConfig);
            } else if (type === 'hydration') {
                chartConfig.options.scales = { y: { beginAtZero: true, title: { display: true, text: 'Volume (ml)' } } };
                hydrationChartInstance = new Chart(ctx, chartConfig);
            } else if (type === 'breath') {
                 chartConfig.options.scales = { y: { beginAtZero: true, title: { display: true, text: 'Minutes' } } }; // Updated to minutes
                 breathChartInstance = new Chart(ctx, chartConfig);
            }
        }
        
        const renderMoodTrendChart = (period) => renderChart('mood-trend-chart', 'mood', period);
        const renderHabitCompletionChart = (period) => renderChart('habit-completion-chart', 'habit', period);
        const renderSleepTrendChart = (period) => renderChart('sleep-trend-chart', 'sleep', period);
        const renderHydrationTrendChart = (period) => renderChart('hydration-analytics-chart', 'hydration', period);
        const renderBreathTrendChart = (period) => renderChart('breath-trend-chart', 'breath', period);

        function getChartData(period, type) {
            const now = new Date();
            let startDate = new Date();
            startDate.setHours(0, 0, 0, 0); // Normalize to start of day

            if (period === 'today') {
                // startDate is already set to today 00:00:00
            } else if (period.endsWith('days')) {
                const daysBack = parseInt(period.replace('days', ''));
                startDate.setDate(now.getDate() - (daysBack - 1));
                startDate.setHours(0, 0, 0, 0);
            } else if (period === 'alldays') {
                const allTimestamps = [
                    ...moodLogs.map(l => new Date(l.timestamp).getTime()),
                    ...sleepLogs.map(l => new Date(l.date).getTime()),
                    ...breathLogs.map(l => new Date(l.timestamp).getTime())
                ].filter(t => !isNaN(t));

                const earliestHabitDate = Object.values(dailyHabitStatuses)
                    .flatMap(habitDay => Object.keys(habitDay))
                    .map(dateStr => new Date(dateStr).getTime())
                    .filter(t => !isNaN(t))
                    .sort((a,b) => a - b)[0];

                if (earliestHabitDate) allTimestamps.push(earliestHabitDate);

                if (allTimestamps.length > 0) {
                    startDate = new Date(Math.min(...allTimestamps));
                    startDate.setHours(0, 0, 0, 0);
                } else {
                    startDate = now; // No data, default to today
                    startDate.setHours(0, 0, 0, 0);
                }
            }
            
            const labels = [];
            const dataPoints = {};
            let tempDate = new Date(startDate);
            while (tempDate <= now) {
                const dateKey = toYYYYMMDD(tempDate);
                labels.push(tempDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                dataPoints[dateKey] = {
                    mood: { total: 0, count: 0 },
                    habit: { completed: 0, skipped: 0 },
                    sleep: { total: 0, count: 0 },
                    hydration: { total: 0, goal: 0 },
                    breath: { total: 0, count: 0 }
                };
                tempDate.setDate(tempDate.getDate() + 1);
            }

            let noData = true; // Flag to check if any data is present for the period

            if(type === 'mood') {
                moodLogs.forEach(log => {
                    const dateKey = toYYYYMMDD(new Date(log.timestamp));
                    if (dataPoints[dateKey]) { dataPoints[dateKey].mood.total += log.moodLevel; dataPoints[dateKey].mood.count++; noData = false; }
                });
                const data = Object.values(dataPoints).map(dp => dp.mood.count > 0 ? (dp.mood.total / dp.mood.count) : null);
                return { labels, datasets: [{ label: 'Average Mood', data: data, borderColor: '#4F46E5', fill: true, tension: 0.3, spanGaps: true }], noData: data.every(d => d === null) };
            } else if (type === 'habit') {
                habits.filter(h => !h.isArchived).forEach(habit => { // Only count non-archived habits for chart
                    Object.entries(dailyHabitStatuses[habit.id] || {}).forEach(([dateKey, status]) => {
                        if (dataPoints[dateKey]) {
                            if (status === 'completed') dataPoints[dateKey].habit.completed++;
                            else if (status === 'skipped') dataPoints[dateKey].habit.skipped++;
                            noData = false;
                        }
                    });
                });
                const completedData = Object.values(dataPoints).map(dp => dp.habit.completed);
                const skippedData = Object.values(dataPoints).map(dp => dp.habit.skipped);
                return { labels, datasets: { completed: { label: 'Completed', data: completedData, backgroundColor: '#10B981' }, skipped: { label: 'Skipped', data: skippedData, backgroundColor: '#F59E0B' } }, noData: completedData.every(d => d === 0) && skippedData.every(d => d === 0) };
            } else if (type === 'sleep') {
                sleepLogs.forEach(log => {
                    const dateKey = toYYYYMMDD(new Date(log.date));
                    if (dataPoints[dateKey]) { dataPoints[dateKey].sleep.total += log.duration; dataPoints[dateKey].sleep.count++; noData = false; }
                });
                const data = Object.values(dataPoints).map(dp => dp.sleep.count > 0 ? (dp.sleep.total / dp.sleep.count) : null);
                return { labels, datasets: [{ label: 'Average Sleep Hours', data: data, borderColor: '#2563EB', fill: false, tension: 0.3, spanGaps: true }], noData: data.every(d => d === null) };
            } else if (type === 'hydration') {
                Object.entries(hydrationLogs).forEach(([dateKey, log]) => {
                    if (dataPoints[dateKey]) { dataPoints[dateKey].hydration.total = log.totalIntake; noData = false; }
                });
                const totalIntakeData = Object.values(dataPoints).map(dp => dp.hydration.total);
                const goalData = Array(labels.length).fill(dailyWaterNeed > 0 ? dailyWaterNeed : null);
                
                const datasets = [
                    { label: 'Daily Intake (ml)', data: totalIntakeData, borderColor: DRINK_COLORS['water'], fill: false, tension: 0.3, spanGaps: true },
                ];
                if (dailyWaterNeed > 0) {
                    datasets.push({
                        label: 'Daily Goal (ml)',
                        data: goalData,
                        borderColor: '#A5B4FC',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    });
                }
                return { labels, datasets, noData: totalIntakeData.every(d => d === 0) };

            } else if (type === 'breath') {
                breathLogs.forEach(log => {
                    const dateKey = toYYYYMMDD(new Date(log.timestamp));
                    if (dataPoints[dateKey]) { dataPoints[dateKey].breath.total += (log.elapsedTime / 60); dataPoints[dateKey].breath.count++; noData = false; } // Converted to minutes
                });
                const data = Object.values(dataPoints).map(dp => dp.breath.count > 0 ? (dp.breath.total / dp.breath.count) : null);
                return { labels, datasets: [{ label: 'Average Session Duration (minutes)', data: data, borderColor: '#EF4444', fill: false, tension: 0.3, spanGaps: true }], noData: data.every(d => d === null) }; // Updated label
            }
            return { labels: [], datasets: {}, noData: true }; // Fallback
        }
        
        async function checkAndResetHabits() {
            if (hasResetBeenChecked || !habits.length) return;
            hasResetBeenChecked = true;

            const metadata = JSON.parse(localStorage.getItem(LS_METADATA) || '{}');
            const lastResetTimestamp = metadata.lastReset ? new Date(metadata.lastReset) : null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (!lastResetTimestamp || lastResetTimestamp.getTime() >= today.getTime()) {
                localStorage.setItem(LS_METADATA, JSON.stringify({ ...metadata, lastReset: new Date().toISOString() }));
                return;
            }

            let operations = 0;
            let lastResetDate = new Date(lastResetTimestamp);
            
            for (let d = new Date(lastResetDate); d < today; d.setDate(d.getDate() + 1)) {
                const dateKey = toYYYYMMDD(d);
                habits.filter(h => !h.isArchived).forEach(habit => { // Only consider non-archived habits for auto-skipping
                    if (isHabitDueOn(habit, d)) {
                        const status = getHabitStatusOnDate(habit.id, dateKey);
                        if (status === 'pending') {
                            if (!dailyHabitStatuses[habit.id]) {
                                dailyHabitStatuses[habit.id] = {};
                            }
                            dailyHabitStatuses[habit.id][dateKey] = 'skipped';
                            operations++;
                        }
                    }
                });
            }
            
            if(operations > 0) {
                 saveData(); 
            }
            localStorage.setItem(LS_METADATA, JSON.stringify({ ...metadata, lastReset: new Date().toISOString() }));
        }

        // Renamed and modified to render summary into a specific container
        function renderSummaryStatistics(period) {
            const summary = getSummaryStatistics(period);
            const container = document.getElementById('summary-statistics-container');
            if (!container) return;

            container.innerHTML = `
                <div class="bg-white p-4 rounded-lg shadow-sm text-center">
                    <p class="text-lg font-semibold text-gray-700">Avg Mood</p>
                    <p class="text-3xl font-bold text-indigo-600">${summary.avgMood}</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-sm text-center">
                    <p class="text-lg font-semibold text-gray-700">Avg Sleep</p>
                    <p class="text-3xl font-bold text-green-600">${summary.avgSleepHours} hrs</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-sm text-center">
                    <p class="text-lg font-semibold text-gray-700">Habit Comp.</p>
                    <p class="text-3xl font-bold text-purple-600">${summary.habitCompletionRate}%</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-sm text-center">
                    <p class="text-lg font-semibold text-gray-700">Avg Hydration</p>
                    <p class="text-3xl font-bold text-blue-600">${summary.avgDailyHydration} ml</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-sm text-center">
                    <p class="text-lg font-semibold text-gray-700">Avg Breath Session</p>
                    <p class="text-3xl font-bold text-red-600">${(summary.avgBreathSessionDuration / 60).toFixed(1)} min</p> <!-- Converted to minutes for display -->
                </div>
            `;
        }


        function getFilteredDataByPeriod(period) {
            const now = new Date();
            let startDate = new Date();
            startDate.setHours(0, 0, 0, 0); // Normalize to start of day

            if (period === 'today') {
                // startDate is already set to today 00:00:00
            } else if (period.endsWith('days')) {
                const daysBack = parseInt(period.replace('days', ''));
                startDate.setDate(now.getDate() - (daysBack - 1));
                startDate.setHours(0, 0, 0, 0);
            } else if (period === 'alldays') {
                const allTimestamps = [
                    ...moodLogs.map(l => new Date(l.timestamp).getTime()),
                    ...sleepLogs.map(l => new Date(l.date).getTime()),
                    ...breathLogs.map(l => new Date(l.timestamp).getTime())
                ].filter(t => !isNaN(t));

                const earliestHabitDate = Object.values(dailyHabitStatuses)
                    .flatMap(habitDay => Object.keys(habitDay))
                    .map(dateStr => new Date(dateStr).getTime())
                    .filter(t => !isNaN(t))
                    .sort((a,b) => a - b)[0];

                if (earliestHabitDate) allTimestamps.push(earliestHabitDate);

                if (allTimestamps.length > 0) {
                    startDate = new Date(Math.min(...allTimestamps));
                    startDate.setHours(0, 0, 0, 0);
                } else {
                    startDate = now;
                    startDate.setHours(0, 0, 0, 0);
                }
            }
            
            const filteredMoodLogs = moodLogs.filter(log => new Date(log.timestamp) >= startDate);
            const filteredSleepLogs = sleepLogs.filter(log => new Date(log.date) >= startDate);
            const filteredBreathLogs = breathLogs.filter(log => new Date(log.timestamp) >= startDate);

            const filteredHydrationLogs = Object.entries(hydrationLogs)
                .filter(([dateKey]) => new Date(dateKey) >= startDate)
                .reduce((acc, [dateKey, log]) => {
                    acc[dateKey] = log;
                    return acc;
                }, {});

            const filteredHabitsWithStatus = [];
            let tempDate = new Date(startDate);
            while (tempDate <= now) {
                const dateKey = toYYYYMMDD(tempDate);
                // Important: For analytics, consider all habits, even archived ones, if their data exists in the period
                habits.forEach(habit => {
                    if (isHabitDueOn(habit, tempDate) || dailyHabitStatuses[habit.id]?.[dateKey]) { // Include if due or has status
                        const status = getHabitStatusOnDate(habit.id, dateKey);
                        filteredHabitsWithStatus.push({ habitId: habit.id, date: dateKey, status: status });
                    }
                });
                tempDate.setDate(tempDate.getDate() + 1);
            }
            
            return { filteredMoodLogs, filteredSleepLogs, filteredBreathLogs, filteredHydrationLogs, filteredHabitsWithStatus };
        }


        function getSummaryStatistics(period) {
            const { filteredMoodLogs, filteredSleepLogs, filteredBreathLogs, filteredHydrationLogs, filteredHabitsWithStatus } = getFilteredDataByPeriod(period);

            const avgMood = filteredMoodLogs.length > 0 ? (filteredMoodLogs.reduce((sum, log) => sum + log.moodLevel, 0) / filteredMoodLogs.length).toFixed(1) : '--';

            const avgSleepHours = filteredSleepLogs.length > 0 ? (filteredSleepLogs.reduce((sum, log) => sum + log.duration, 0) / filteredSleepLogs.length).toFixed(1) : '--';
            
            let totalHabitsCompleted = filteredHabitsWithStatus.filter(item => item.status === 'completed').length;
            let totalHabitsDue = filteredHabitsWithStatus.length;
            
            const habitCompletionRate = totalHabitsDue > 0 ? ((totalHabitsCompleted / totalHabitsDue) * 100).toFixed(0) : '--';

            let totalHydrationIntake = 0;
            let hydrationDaysCount = 0;
            Object.values(filteredHydrationLogs).forEach(log => {
                totalHydrationIntake += log.totalIntake;
                hydrationDaysCount++;
            });
            const avgDailyHydration = hydrationDaysCount > 0 ? (totalHydrationIntake / hydrationDaysCount).toFixed(0) : '--';

            let totalBreathDuration = 0;
            let breathSessionCount = 0;
            filteredBreathLogs.forEach(log => {
                totalBreathDuration += log.elapsedTime;
                breathSessionCount++;
            });
            const avgBreathSessionDuration = breathSessionCount > 0 ? (totalBreathDuration / breathSessionCount).toFixed(1) : '--';

            return {
                avgMood,
                avgSleepHours,
                habitCompletionRate,
                avgDailyHydration,
                avgBreathSessionDuration
            };
        }


        // --- Gemini API Integrations ---
        async function generateMoodInsight() {
            const journalEntry = document.getElementById('mood-notes').value.trim();
            const insightContainer = document.getElementById('mood-insight-container');
            insightContainer.innerHTML = ''; 
            insightContainer.appendChild(moodInsightOutput); 

            if (!journalEntry) {
                moodInsightOutput.textContent = 'Please write something in your journal entry to get an insight.';
                moodInsightOutput.classList.remove('hidden');
                return;
            }

            moodInsightOutput.textContent = 'Generating insight...';
            moodInsightOutput.classList.remove('hidden');
            moodInsightOutput.classList.add('loading-text'); 

            try {
                const prompt = `Analyze the following journal entry and provide a concise, empathetic insight or summary of the sentiment and key themes. Keep it to 1-2 sentences. Journal Entry: "${journalEntry}"`;
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    moodInsightOutput.textContent = text;
                } else {
                    moodInsightOutput.textContent = 'Could not generate insight. Please try again.';
                }
            } catch (error) {
                console.error("Error generating mood insight:", error);
                moodInsightOutput.textContent = 'Error generating insight. Please check your network connection.';
            } finally {
                moodInsightOutput.classList.remove('loading-text'); 
            }
        }

        async function generateHabitSuggestions() {
            console.log("generateHabitSuggestions called.");
            habitSuggestionsOutput.innerHTML = '';
            habitSuggestionsOutput.classList.remove('hidden');
            habitSuggestionsOutput.classList.add('loading-text');
            habitSuggestionsOutput.textContent = 'Generating suggestions... Please wait.';

            try {
                const prompt = `Generate 3 to 5 unique and beneficial daily habits related to personal well-being, productivity, or learning. Return them as a JSON object with a single key "habits" whose value is an array of strings. Each string should be a habit. Example: {"habits": ["Read 10 pages", "Hydrate with 2L water", "Meditate for 10 min"]}.`;
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { 
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "habits": {
                                    "type": "ARRAY",
                                    "items": { "type": "STRING" }
                                }
                            }
                        }
                    }
                };
                const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                console.log("Sending habit suggestion request to Gemini API...");
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                console.log("Gemini API response received:", result);

                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    console.log("Raw JSON response part:", json);
                    try {
                        const parsedJson = JSON.parse(json);
                        if (parsedJson.habits && Array.isArray(parsedJson.habits)) {
                            habitSuggestionsOutput.innerHTML = '<strong>Suggestions:</strong> ' + parsedJson.habits.join(', ');
                        } else {
                            habitSuggestionsOutput.textContent = 'Could not parse habit suggestions. The response structure was unexpected, received: ' + JSON.stringify(parsedJson);
                            console.error("Unexpected JSON structure:", parsedJson);
                        }
                    } catch (parseError) {
                        habitSuggestionsOutput.textContent = 'Failed to parse habit suggestions from the response. Raw response: ' + json;
                        console.error("JSON parsing error:", parseError, "Raw JSON:", json);
                    }
                } else {
                    habitSuggestionsOutput.textContent = 'No habit suggestions generated. The API response was empty or malformed.';
                    console.error("API response missing candidates or content:", result);
                }
            } catch (error) {
                console.error("Error generating habit suggestions (fetch failed or API error):", error);
                habitSuggestionsOutput.textContent = `Error generating suggestions: ${error.message}. Please check your network connection and try again.`;
            } finally {
                habitSuggestionsOutput.classList.remove('loading-text');
            }
        }

        async function calculateWaterNeed() {
            const age = document.getElementById('user-age').value;
            const weight = document.getElementById('user-weight').value;
            const activityLevel = document.getElementById('activity-level').value;
            const climate = document.getElementById('climate').value;
            const outputElement = document.getElementById('water-need-output');

            if (!age || !weight || age <= 0 || weight <= 0) {
                outputElement.textContent = 'Please enter valid age and weight.';
                outputElement.classList.remove('hidden');
                return;
            }

            outputElement.textContent = 'Calculating water need...';
            outputElement.classList.remove('hidden');
            outputElement.classList.add('loading-text');

            try {
                const prompt = `As a certified nutritionist or hydration expert, calculate the estimated daily minimum water intake in milliliters for a person with the following characteristics, based on general health guidelines and scientific research. Provide a realistic and research-backed estimate, considering all factors.
                - Age: ${age} years
                - Weight: ${weight} kg
                - Activity Level: ${activityLevel.replace('_', ' ')}
                - Climate: ${climate.replace('_', ' ')}
                Provide only the numerical value in ml within a JSON object. Example: {"waterNeedMl": 2500}`;
                
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "waterNeedMl": { "type": "NUMBER" }
                            }
                        }
                    }
                };
                const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(json);
                    if (typeof parsedJson.waterNeedMl === 'number') {
                        dailyWaterNeed = parsedJson.waterNeedMl;
                        const metadata = JSON.parse(localStorage.getItem(LS_METADATA) || '{}');
                        localStorage.setItem(LS_METADATA, JSON.stringify({ ...metadata, dailyWaterNeed }));
                        outputElement.textContent = `Your estimated daily water need is: ${dailyWaterNeed} ml`;
                        const displayWaterNeedEl = document.getElementById('display-water-need');
                        if (displayWaterNeedEl) {
                            displayWaterNeedEl.textContent = `${dailyWaterNeed} ml`;
                        }
                        updateHydrationChart(); 
                    } else {
                        outputElement.textContent = 'Could not calculate water need. Please check your inputs or try again.';
                    }
                } else {
                    outputElement.textContent = 'Could not calculate water need. Please try again.';
                }
            } catch (error) {
                console.error("Error calculating water need:", error);
                outputElement.textContent = 'Error calculating water need. Please check your network connection.';
            } finally {
                outputElement.classList.remove('loading-text');
            }
        }

        async function logHydration(drinkType, quantity) {
            console.log("logHydration called with:", { drinkType, quantity });
            const todayKey = toYYYYMMDD(new Date());
            
            if (!hydrationLogs[todayKey]) {
                hydrationLogs[todayKey] = { totalIntake: 0, logs: [] };
                console.log("Initialized hydrationLogs for today:", hydrationLogs[todayKey]);
            }

            const waterEquivalent = quantity * BEVERAGE_WATER_EQUIVALENT[drinkType];
            console.log("Water equivalent:", waterEquivalent);

            hydrationLogs[todayKey].totalIntake = (hydrationLogs[todayKey].totalIntake || 0) + waterEquivalent;
            console.log("New totalIntake for today:", hydrationLogs[todayKey].totalIntake);

            hydrationLogs[todayKey].logs.push({
                type: drinkType,
                quantity: quantity,
                waterEquivalent: waterEquivalent,
                timestamp: new Date().toISOString()
            });

            dailyIntake = hydrationLogs[todayKey].totalIntake;
            console.log("Updated dailyIntake global variable:", dailyIntake);
            saveData(); 
            
            updateHydrationChart();
            const displayCurrentIntakeEl = document.getElementById('display-current-intake');
            if (displayCurrentIntakeEl) {
                displayCurrentIntakeEl.textContent = `${dailyIntake.toFixed(0)} ml`;
                console.log("UI display updated for current intake.");
            }
        }

        function updateHydrationChart() {
            console.log("updateHydrationChart called.");
            const canvas = document.getElementById('hydration-chart');
            const displayWaterNeedEl = document.getElementById('display-water-need');
            const displayCurrentIntakeEl = document.getElementById('display-current-intake');
            if (!canvas || !displayWaterNeedEl || !displayCurrentIntakeEl) {
                console.log("Chart elements not found, skipping chart update.");
                return; 
            }
            const ctx = canvas.getContext('2d');

            if (hydrationChartInstance) {
                hydrationChartInstance.destroy();
                console.log("Destroyed previous chart instance.");
            }

            const todayKey = toYYYYMMDD(new Date());
            const currentDayLogs = hydrationLogs[todayKey]?.logs || [];
            console.log("Current day logs for chart:", currentDayLogs);

            const aggregatedIntake = {};
            currentDayLogs.forEach(log => {
                aggregatedIntake[log.type] = (aggregatedIntake[log.type] || 0) + log.waterEquivalent;
            });
            console.log("Aggregated intake for chart:", aggregatedIntake);

            let chartLabels = [];
            let chartData = [];
            let chartColors = [];

            for (const type in aggregatedIntake) {
                chartLabels.push(`${type.replace('-', ' ')} (${aggregatedIntake[type].toFixed(0)}ml)`);
                chartData.push(aggregatedIntake[type]); 
                chartColors.push(DRINK_COLORS[type]);
            }
            console.log("Chart labels:", chartLabels);
            console.log("Chart data:", chartData);

            const remainingWater = Math.max(0, dailyWaterNeed - dailyIntake);
            console.log("Remaining water:", remainingWater);
            console.log("Daily water need:", dailyWaterNeed);
            console.log("Daily intake (used for remaining):", dailyIntake);
            if (dailyWaterNeed > 0 && remainingWater > 0) {
                chartLabels.push(`Remaining (${remainingWater.toFixed(0)}ml)`);
                chartData.push(remainingWater);
                chartColors.push(DRINK_COLORS['remaining']);
            } else if (dailyWaterNeed === 0 && dailyIntake === 0) {
                chartLabels.push('No Goal / No Intake');
                chartData.push(1); 
                chartColors.push(DRINK_COLORS['remaining']);
            }

            if (dailyWaterNeed > 0 && dailyIntake >= dailyWaterNeed) {
                if (chartLabels.length === 0) { 
                     chartLabels.push(`Goal Reached (${dailyIntake.toFixed(0)}ml)`);
                     chartData.push(dailyIntake);
                     chartColors.push(DRINK_COLORS['water']); 
                }
            }


            hydrationChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        data: chartData,
                        backgroundColor: chartColors,
                        borderColor: '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%', 
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                padding: 15
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed;
                                    const originalLabel = context.label.split(' (')[0]; 
                                    return `${originalLabel}: ${value.toFixed(0)}ml`;
                                }
                            }
                        }
                    }
                }
            });
            console.log("Chart instance created/updated.");

            const percentageTextElement = document.getElementById('hydration-percentage-text');
            if (percentageTextElement) {
                const percentage = dailyWaterNeed > 0 ? ((dailyIntake / dailyWaterNeed) * 100) : 0;
                percentageTextElement.textContent = `${percentage.toFixed(0)}% fulfilled`;
                if (percentage >= 100) {
                    percentageTextElement.classList.remove('text-orange-500');
                    percentageTextElement.classList.add('text-green-600');
                } else {
                    percentageTextElement.classList.remove('text-green-600');
                    percentageTextElement.classList.add('text-orange-500');
                }
                console.log("Percentage text updated to:", percentageTextElement.textContent);
            }
        }

        const scheduleHabitNotifications = () => {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            const todayKey = toYYYYMMDD(now);

            habits.forEach(habit => {
                if (isHabitDueOn(habit, now) && habit.habitReminderTime) {
                    const habitStatus = getHabitStatusOnDate(habit.id, todayKey);

                    if (habit.habitReminderTime === currentTime && habitStatus === 'pending' && !notificationsSentToday[habit.id]) {
                        if (Notification.permission === "granted") {
                            new Notification("Habit Reminder!", {
                                body: `Time to "${habit.name}"!`,
                                icon: "https://cdn-icons-png.flaticon.com/512/3448/3448338.png"
                            });
                            notificationsSentToday[habit.id] = true; 
                            saveNotificationsSent(); 
                        } else {
                            console.log(`Notification permission not granted for habit: ${habit.name}`);
                        }
                    }
                }
            });
        };

        // --- Sleep Tracking Functions ---
        async function handleLogSleep() {
            const sleepDate = document.getElementById('sleep-date').value;
            const sleepHours = parseInt(document.getElementById('sleep-hours').value);
            const sleepMinutes = parseInt(document.getElementById('sleep-minutes').value);
            const sleepQuality = parseInt(document.getElementById('sleep-quality-slider').value); // New
            const sleepAbnormalities = document.getElementById('sleep-abnormalities').value.trim();
            const loggingStatusEl = document.getElementById('sleep-logging-status');

            if (!sleepDate || isNaN(sleepHours) || isNaN(sleepMinutes) || (sleepHours === 0 && sleepMinutes === 0)) {
                loggingStatusEl.textContent = "Please enter valid sleep duration.";
                loggingStatusEl.classList.remove('hidden');
                return;
            }

            const totalDuration = sleepHours + (sleepMinutes / 60); 
            
            const newSleepLog = {
                id: generateUniqueId(),
                date: sleepDate, 
                duration: parseFloat(totalDuration.toFixed(2)),
                sleepQuality: sleepQuality, // New
                abnormalities: sleepAbnormalities,
                analysis: null
            };

            sleepLogs.push(newSleepLog);
            saveData();
            console.log("Sleep logged:", newSleepLog);

            // Clear form
            document.getElementById('sleep-abnormalities').value = '';
            document.getElementById('sleep-hours').value = 8;
            document.getElementById('sleep-minutes').value = 0;
            document.getElementById('sleep-quality-slider').value = 3; // Reset quality slider
            document.getElementById('sleep-quality-value').textContent = 3; // Reset quality display
            loggingStatusEl.classList.add('hidden');

            renderContentForSection('sleep-tracking-section');
            renderContentForSection('dashboard-section'); 
            
            if (sleepAbnormalities) {
                analyzeAndSaveSleepLog(newSleepLog.id, newSleepLog.duration, sleepAbnormalities);
            }
        }

        async function deleteSleepLog(id) {
            showConfirmation('Delete Sleep Log?', 'This will be permanent.', () => {
                sleepLogs = sleepLogs.filter(log => log.id !== id);
                saveData();
                renderContentForSection('sleep-tracking-section');
            });
        }

        async function analyzeAndSaveSleepLog(logId, duration, abnormalities) {
            const logIndex = sleepLogs.findIndex(log => log.id === logId);
            if (logIndex === -1) return;

            const loadingEl = document.getElementById(`sleep-analysis-loading-${logId}`);
            if (loadingEl) {
                loadingEl.textContent = 'Generating analysis...';
                loadingEl.classList.remove('hidden');
                loadingEl.classList.add('loading-text');
            } else {
                console.log(`No specific loading element found for log ${logId}, proceeding with analysis.`);
            }

            try {
                const prompt = `Analyze the following sleep data and provide a concise, helpful insight or suggestions for improvement (1-2 sentences). Consider both duration and notes.
                Sleep Duration: ${duration} hours. Notes/Abnormalities: "${abnormalities}"`;
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    sleepLogs[logIndex].analysis = text;
                    saveData();
                } else {
                    console.error(`Could not generate analysis for log ${logId}: Unexpected API response.`);
                    sleepLogs[logIndex].analysis = 'Analysis failed.'; // Indicate failure
                    saveData();
                }
            } catch (error) {
                console.error(`Error generating sleep analysis for log ${logId}:`, error);
                sleepLogs[logIndex].analysis = 'Error during analysis.'; // Indicate error
                saveData();
            } finally {
                renderContentForSection('sleep-tracking-section'); 
            }
        }

        async function analyzeMissingSleepAnalysesOnLoad() {
            const logsToAnalyze = sleepLogs.filter(log => log.abnormalities && !log.analysis);
            if (logsToAnalyze.length > 0) {
                console.log(`Found ${logsToAnalyze.length} sleep logs needing analysis. Analyzing...`);
                for (const log of logsToAnalyze) {
                    await analyzeAndSaveSleepLog(log.id, log.duration, log.abnormalities);
                }
            }
        }


        // --- Breath Helper Functions ---
        function updateBreathingCircle(phase, duration) {
            const circle = document.getElementById('breathing-circle');
            const text = document.getElementById('breathing-text');
            if (!circle || !text) return;

            circle.className = 'breathing-circle-container'; // Reset classes
            document.documentElement.style.setProperty('--inhale-duration', `${inhaleDuration}s`);
            document.documentElement.style.setProperty('--hold-duration', `${holdDuration}s`);
            document.documentElement.style.setProperty('--exhale-duration', `${exhaleDuration}s`);

            switch (phase) {
                case 'inhale':
                    circle.classList.add('breathing-in');
                    text.textContent = 'Breathe In';
                    break;
                case 'hold':
                    circle.classList.add('breathing-hold');
                    text.textContent = 'Hold';
                    break;
                case 'exhale':
                    circle.classList.add('breathing-out');
                    text.textContent = 'Breathe Out';
                    break;
                default:
                    text.textContent = 'Start';
                    break;
            }
        }

        function breatheCycle() {
            clearTimeout(phaseTimeoutId);

            updateBreathingCircle('inhale', inhaleDuration);
            phaseTimeoutId = setTimeout(() => {
                updateBreathingCircle('hold', holdDuration);
                phaseTimeoutId = setTimeout(() => {
                    updateBreathingCircle('exhale', exhaleDuration);
                    phaseTimeoutId = setTimeout(() => {
                        breatheCycle(); // Repeat the cycle
                    }, exhaleDuration * 1000);
                }, holdDuration * 1000);
            }, inhaleDuration * 1000);
        }

        function startBreathing() {
            inhaleDuration = parseInt(document.getElementById('inhale-duration-input').value) || 4;
            holdDuration = parseInt(document.getElementById('hold-duration-input').value) || 4;
            exhaleDuration = parseInt(document.getElementById('exhale-duration-input').value) || 4;

            if (inhaleDuration <= 0) inhaleDuration = 1;
            if (exhaleDuration <= 0) exhaleDuration = 1;

            stopBreathing(false); // Clear any existing cycle, but don't log automatically
            sessionStartTime = Date.now(); // Start the session timer
            breatheCycle();
            console.log(`Breathing started: Inhale ${inhaleDuration}s, Hold ${holdDuration}s, Exhale ${exhaleDuration}s`);
        }

        function stopBreathing(logSession = true) { // Added parameter to control logging
            clearTimeout(phaseTimeoutId);
            breathingInterval = null; 
            const circle = document.getElementById('breathing-circle');
            const text = document.getElementById('breathing-text');
            if (circle) circle.className = 'breathing-circle-container'; 
            if (text) text.textContent = 'Start';

            if (logSession && sessionStartTime) {
                const elapsedTime = (Date.now() - sessionStartTime) / 1000; // in seconds
                handleLogBreathingSession(elapsedTime); // Pass the elapsed time to the log function
            }
            sessionStartTime = null; // Reset the session start time
            console.log("Breathing stopped.");
        }

        async function handleLogBreathingSession(elapsedTimeOverride = null) {
            const currentInhale = parseInt(document.getElementById('inhale-duration-input').value) || 4;
            const currentHold = parseInt(document.getElementById('hold-duration-input').value) || 4;
            const currentExhale = parseInt(document.getElementById('exhale-duration-input').value) || 4;
            const patternTotalDuration = currentInhale + currentHold + currentExhale; 
            
            const elapsedTime = elapsedTimeOverride !== null ? elapsedTimeOverride : (sessionStartTime ? (Date.now() - sessionStartTime) / 1000 : 0);

            const newBreathLog = {
                id: generateUniqueId(),
                timestamp: new Date().toISOString(),
                inhaleDuration: currentInhale,
                holdDuration: currentHold,
                exhaleDuration: currentExhale,
                patternTotalDuration: patternTotalDuration, 
                elapsedTime: elapsedTime 
            };

            breathLogs.push(newBreathLog);
            saveData();
            console.log("Breathing session logged:", newBreathLog);

            renderContentForSection('breath-helper-section');
        }

        async function deleteBreathLog(id) {
            showConfirmation('Delete Breathing Log?', 'This will be permanent.', () => {
                breathLogs = breathLogs.filter(log => log.id !== id);
                saveData();
                renderContentForSection('breath-helper-section');
            });
        }

        async function generatePersonalizedRecommendations(period = '7days') { // Default period
            const recommendationsOutput = document.getElementById('recommendations-output');
            const recommendationsContent = document.getElementById('recommendations-content');
            
            recommendationsOutput.textContent = 'Generating recommendations based on your data...';
            recommendationsOutput.classList.remove('hidden');
            recommendationsOutput.classList.add('loading-text');
            recommendationsContent.innerHTML = ''; // Clear previous content

            // Update active state for filter buttons
            document.querySelectorAll('.recommendation-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === period);
            });

            // Filter data based on period
            const { filteredMoodLogs, filteredSleepLogs, filteredBreathLogs, filteredHydrationLogs, filteredHabitsWithStatus } = getFilteredDataByPeriod(period);

            // Aggregate data for the prompt
            const avgMood = filteredMoodLogs.length > 0 ? (filteredMoodLogs.reduce((sum, log) => sum + log.moodLevel, 0) / filteredMoodLogs.length).toFixed(1) : 'N/A';
            const moodNotesSummary = filteredMoodLogs.map(log => log.notes).filter(Boolean).join('. ');
            const moodTagsSummary = [...new Set(filteredMoodLogs.flatMap(log => log.tags || [])).values()].join(', ');

            const avgSleepHours = filteredSleepLogs.length > 0 ? (filteredSleepLogs.reduce((sum, log) => sum + log.duration, 0) / filteredSleepLogs.length).toFixed(1) : 'N/A';
            const avgSleepQuality = filteredSleepLogs.length > 0 ? (filteredSleepLogs.reduce((sum, log) => sum + (log.sleepQuality || 0), 0) / filteredSleepLogs.length).toFixed(1) : 'N/A';
            const sleepAbnormalitiesSummary = filteredSleepLogs.map(log => log.abnormalities).filter(Boolean).join('. ');

            const avgBreathSessionDuration = filteredBreathLogs.length > 0 ? (filteredBreathLogs.reduce((sum, log) => sum + log.elapsedTime, 0) / filteredBreathLogs.length).toFixed(1) : 'N/A';


            // Calculate habit completion rates within the period, considering only non-archived habits
            const nonArchivedHabitsForRecommendations = habits.filter(h => !h.isArchived);
            const habitCompletionRates = nonArchivedHabitsForRecommendations.map(h => {
                let completedCount = 0;
                let totalDueCount = 0;
                filteredHabitsWithStatus.filter(item => item.habitId === h.id).forEach(item => {
                    // Re-check isHabitDueOn to ensure filtering by archived status and dates
                    if (isHabitDueOn(h, new Date(item.date))) {
                        totalDueCount++;
                        if (item.status === 'completed') {
                            completedCount++;
                        }
                    }
                });
                const completionRate = totalDueCount > 0 ? ((completedCount / totalDueCount) * 100).toFixed(0) : 'N/A';
                const goalInfo = h.goalType && h.goalValue ? ` (Goal: ${h.goalValue} ${h.goalUnit || h.goalType})` : '';
                return `Habit: "${h.name}" (Completion: ${completionRate}% over selected period)${goalInfo}`;
            }).join('; ');

            const hydrationInfo = `Daily Water Need: ${dailyWaterNeed} ml, Current Daily Intake: ${filteredHydrationLogs[toYYYYMMDD(new Date())]?.totalIntake.toFixed(0) || 0} ml (today)`;

            // Construct prompt for Gemini API
            const prompt = `Based on the following user data for the period "${period}", provide personalized, actionable recommendations to improve their well-being. Focus on holistic advice, connecting different aspects of their health.
            
            **User Data for Last ${period} (or all time if specified):**
            - Average Mood: ${avgMood} (on a scale of 1-10). Journal entries notes: "${moodNotesSummary || 'No recent notes.'}". Mood tags: "${moodTagsSummary || 'No recent tags.'}"
            - Average Sleep: ${avgSleepHours} hours. Average Sleep Quality: ${avgSleepQuality}/5. Sleep notes/abnormalities: "${sleepAbnormalitiesSummary || 'No recent abnormalities.'}"
            - Habits: ${nonArchivedHabitsForRecommendations.length > 0 ? habitCompletionRates : 'No habits tracked.'}
            - Hydration: ${hydrationInfo}
            - Average Breathing Session Duration: ${avgBreathSessionDuration} seconds.

            **Instructions for Recommendations:**
            1.  Identify 2-3 key areas for improvement based on the data provided for the selected period.
            2.  Provide specific, actionable tips for each area.
            3.  Keep the language encouraging and supportive.
            4.  Format the recommendations as a Markdown list. If insufficient data is available for the period, offer general well-being tips.`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    recommendationsContent.innerHTML = marked.parse(text); 
                    recommendationsOutput.classList.add('hidden');
                } else {
                    recommendationsContent.textContent = 'Could not generate recommendations. Please try again.';
                    recommendationsOutput.classList.add('hidden'); 
                }
            } catch (error) {
                console.error("Error generating recommendations:", error);
                recommendationsContent.textContent = 'Error generating recommendations. Please check your network connection.';
                recommendationsOutput.classList.add('hidden'); 
            } finally {
                recommendationsOutput.classList.remove('loading-text'); 
            }
        }

        // New: Journaling Prompt
        async function generateJournalPrompt() {
            const promptContainer = document.getElementById('journal-prompt-container');
            promptContainer.innerHTML = '';
            promptContainer.appendChild(journalPromptOutput);

            journalPromptOutput.textContent = 'Generating prompt...';
            journalPromptOutput.classList.remove('hidden');
            journalPromptOutput.classList.add('loading-text');

            try {
                const prompt = `Generate a single, short (1-2 sentences) reflective journaling prompt focused on well-being, gratitude, or self-discovery.`;
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDVOauS9UsCMuzJ0jKJr8tPhHy97zmlmM0"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    journalPromptOutput.innerHTML = `<strong>Journal Prompt:</strong> ${text}`;
                } else {
                    journalPromptOutput.textContent = 'Could not generate prompt. Please try again.';
                }
            } catch (error) {
                console.error("Error generating journal prompt:", error);
                journalPromptOutput.textContent = 'Error generating prompt. Please check your network connection.';
            } finally {
                journalPromptOutput.classList.remove('loading-text');
            }
        }

        // New: Data Export Function
        function exportDataToJson() {
            console.log("Exporting data to JSON...");
            const dataToExport = {
                moodLogs: moodLogs.map(log => ({ ...log, timestamp: new Date(log.timestamp).toISOString() })),
                habits: habits.map(habit => ({ ...habit, createdAt: new Date(habit.createdAt).toISOString() })),
                dailyHabitStatuses: dailyHabitStatuses,
                sleepLogs: sleepLogs.map(log => ({ ...log, date: new Date(log.date).toISOString() })),
                breathLogs: breathLogs.map(log => ({ ...log, timestamp: new Date(log.timestamp).toISOString() })),
                hydrationLogs: hydrationLogs,
                metadata: JSON.parse(localStorage.getItem(LS_METADATA) || '{}')
            };

            const jsonString = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `zenith_tracker_data_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Data exported successfully.");
        }

        // New: Data Import Function
        function importDataFromJson(event) {
            console.log("Attempting to import data...");
            const file = event.target.files[0];
            const importStatusEl = document.getElementById('import-status');
            importStatusEl.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-yellow-600'); // Clear all previous status styles
            importStatusEl.classList.add('loading-text');
            importStatusEl.textContent = 'Reading file...';
            console.log("Import status: Reading file...");

            if (!file) {
                importStatusEl.textContent = 'No file selected.';
                importStatusEl.classList.remove('loading-text');
                console.log("Import cancelled: No file selected.");
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                let importedData;
                console.log("File loaded, attempting to parse JSON...");
                try {
                    importedData = JSON.parse(e.target.result);
                    console.log("JSON parsed successfully.");
                } catch (error) {
                    console.error("Error parsing imported JSON:", error);
                    importStatusEl.innerHTML = `Error: Invalid JSON file. (${error.message})`;
                    importStatusEl.classList.remove('loading-text');
                    importStatusEl.classList.add('text-red-600');
                    return;
                }
                
                // Call showConfirmation with custom text and color for the OK button
                showConfirmation('Import Data?', 'Importing data will overwrite existing data. Are you sure you want to proceed?', () => {
                    console.log("Import confirmed by user. Starting data validation and application...");
                    const validationErrors = [];
                    let newMoodLogs = [];
                    let newHabits = [];
                    let newDailyHabitStatuses = {}; // Initialize here
                    let newSleepLogs = [];
                    let newBreathLogs = [];
                    let newHydrationLogs = {};
                    let newDailyWaterNeed = 0;

                    // --- Validate Mood Logs ---
                    if (Array.isArray(importedData.moodLogs)) {
                        newMoodLogs = importedData.moodLogs.map(log => {
                            const id = log.id || generateUniqueId();
                            const moodLevel = parseAndValidateNumber(log.moodLevel, 'moodLevel', validationErrors, 1, 10);
                            const notes = typeof log.notes === 'string' ? log.notes : '';
                            const tags = Array.isArray(log.tags) ? log.tags.filter(t => typeof t === 'string') : [];
                            const timestamp = parseAndValidateDate(log.timestamp, 'mood timestamp', validationErrors);

                            if (moodLevel !== null && timestamp !== null) {
                                return { id, moodLevel, notes, tags, timestamp };
                            }
                            validationErrors.push(`Skipping invalid mood log: ${JSON.stringify(log)}`);
                            return null;
                        }).filter(Boolean); // Filter out nulls
                        console.log(`Mood logs processed. Valid: ${newMoodLogs.length}, Skipped: ${importedData.moodLogs.length - newMoodLogs.length}`);
                    } else if (importedData.moodLogs !== undefined) {
                        validationErrors.push('Invalid moodLogs data: Expected an array.');
                    }

                    // --- Validate Habits ---
                    if (Array.isArray(importedData.habits)) {
                        newHabits = importedData.habits.map(habit => {
                            const id = habit.id || generateUniqueId();
                            const name = typeof habit.name === 'string' && habit.name.trim() ? habit.name.trim() : (validationErrors.push('Invalid habit name'), null);
                            const frequency = ['daily', 'specific-days'].includes(habit.frequency) ? habit.frequency : (validationErrors.push('Invalid habit frequency'), null);
                            // FIX: Changed `days.filter` to `habit.days.filter`
                            const days = Array.isArray(habit.days) ? habit.days.filter(d => typeof d === 'string') : [];
                            const startDate = habit.startDate ? parseAndValidateDate(habit.startDate, 'habit startDate', validationErrors) : null;
                            const endDate = habit.endDate ? parseAndValidateDate(habit.endDate, 'habit endDate', validationErrors) : null;
                            const color = typeof habit.color === 'string' ? habit.color : '#A5B4FC';
                            const habitReminderTime = typeof habit.habitReminderTime === 'string' ? habit.habitReminderTime : null;
                            const createdAt = habit.createdAt ? parseAndValidateDate(habit.createdAt, 'habit createdAt', validationErrors) : new Date();
                            const isArchived = typeof habit.isArchived === 'boolean' ? habit.isArchived : false;

                            const goalType = habit.goalType && ['count', 'duration'].includes(habit.goalType) ? habit.goalType : null;
                            const goalValue = habit.goalValue ? parseAndValidateNumber(habit.goalValue, 'habit goalValue', validationErrors, 0) : null;
                            const goalUnit = typeof habit.goalUnit === 'string' ? habit.goalUnit : null;

                            if (name && frequency) { // Basic required fields for a habit
                                return { id, name, frequency, days, startDate: startDate ? startDate.toISOString() : null, endDate: endDate ? endDate.toISOString() : null, color, habitReminderTime, createdAt: createdAt.toISOString(), isArchived, goalType, goalValue, goalUnit };
                            }
                            validationErrors.push(`Skipping invalid habit: ${JSON.stringify(habit)}`);
                            return null;
                        }).filter(Boolean);
                        console.log(`Habits processed. Valid: ${newHabits.length}, Skipped: ${importedData.habits.length - newHabits.length}`);
                    } else if (importedData.habits !== undefined) {
                        validationErrors.push('Invalid habits data: Expected an array.');
                    }

                    // --- Validate Daily Habit Statuses ---
                    if (typeof importedData.dailyHabitStatuses === 'object' && importedData.dailyHabitStatuses !== null) {
                        for (const habitId in importedData.dailyHabitStatuses) {
                            if (typeof importedData.dailyHabitStatuses[habitId] === 'object' && importedData.dailyHabitStatuses[habitId] !== null) {
                                newDailyHabitStatuses[habitId] = {};
                                for (const dateKey in importedData.dailyHabitStatuses[habitId]) {
                                    const status = importedData.dailyHabitStatuses[habitId][dateKey];
                                    if (['completed', 'skipped', 'pending'].includes(status)) {
                                        newDailyHabitStatuses[habitId][dateKey] = status;
                                    } else {
                                        validationErrors.push(`Invalid habit status for ${habitId} on ${dateKey}: ${status}`);
                                    }
                                }
                            } else {
                                validationErrors.push(`Invalid dailyHabitStatuses entry for habitId ${habitId}: Expected an object.`);
                            }
                        }
                        console.log("Daily habit statuses processed.");
                    } else if (importedData.dailyHabitStatuses !== undefined) {
                        validationErrors.push('Invalid dailyHabitStatuses data: Expected an object.');
                    }


                    // --- Validate Sleep Logs ---
                    if (Array.isArray(importedData.sleepLogs)) {
                        newSleepLogs = importedData.sleepLogs.map(log => {
                            const id = log.id || generateUniqueId();
                            const date = parseAndValidateDate(log.date, 'sleep date', validationErrors);
                            const duration = parseAndValidateNumber(log.duration, 'sleep duration', validationErrors, 0, 24);
                            const sleepQuality = parseAndValidateNumber(log.sleepQuality, 'sleep quality', validationErrors, 1, 5);
                            const abnormalities = typeof log.abnormalities === 'string' ? log.abnormalities : '';
                            const analysis = typeof log.analysis === 'string' || log.analysis === null ? log.analysis : null;

                            if (date !== null && duration !== null && sleepQuality !== null) {
                                return { id, date, duration, sleepQuality, abnormalities, analysis };
                            }
                            validationErrors.push(`Skipping invalid sleep log: ${JSON.stringify(log)}`);
                            return null;
                        }).filter(Boolean);
                        console.log(`Sleep logs processed. Valid: ${newSleepLogs.length}, Skipped: ${importedData.sleepLogs.length - newSleepLogs.length}`);
                    } else if (importedData.sleepLogs !== undefined) {
                        validationErrors.push('Invalid sleepLogs data: Expected an array.');
                    }

                    // --- Validate Breath Logs ---
                    if (Array.isArray(importedData.breathLogs)) {
                        newBreathLogs = importedData.breathLogs.map(log => {
                            const id = log.id || generateUniqueId();
                            const timestamp = parseAndValidateDate(log.timestamp, 'breath timestamp', validationErrors);
                            const inhaleDuration = parseAndValidateNumber(log.inhaleDuration, 'inhaleDuration', validationErrors, 0);
                            const holdDuration = parseAndValidateNumber(log.holdDuration, 'holdDuration', validationErrors, 0);
                            const exhaleDuration = parseAndValidateNumber(log.exhaleDuration, 'exhaleDuration', validationErrors, 0);
                            const elapsedTime = parseAndValidateNumber(log.elapsedTime, 'elapsedTime', validationErrors, 0);

                            if (timestamp !== null && inhaleDuration !== null && holdDuration !== null && exhaleDuration !== null && elapsedTime !== null) {
                                return { id, timestamp, inhaleDuration, holdDuration, exhaleDuration, elapsedTime };
                            }
                            validationErrors.push(`Skipping invalid breath log: ${JSON.stringify(log)}`);
                            return null;
                        }).filter(Boolean);
                        console.log(`Breath logs processed. Valid: ${newBreathLogs.length}, Skipped: ${importedData.breathLogs.length - newBreathLogs.length}`);
                    } else if (importedData.breathLogs !== undefined) {
                        validationErrors.push('Invalid breathLogs data: Expected an array.');
                    }

                    // --- Validate Hydration Logs ---
                    if (typeof importedData.hydrationLogs === 'object' && importedData.hydrationLogs !== null) {
                        for (const dateKey in importedData.hydrationLogs) {
                            const dayLog = importedData.hydrationLogs[dateKey];
                            let totalIntake = parseAndValidateNumber(dayLog.totalIntake, `hydration totalIntake for ${dateKey}`, validationErrors, 0);
                            let logs = Array.isArray(dayLog.logs) ? dayLog.logs.filter(log => {
                                const type = typeof log.type === 'string' && BEVERAGE_WATER_EQUIVALENT[log.type] ? log.type : null;
                                const quantity = parseAndValidateNumber(log.quantity, `hydration log quantity for ${dateKey}`, validationErrors, 0);
                                const waterEquivalent = parseAndValidateNumber(log.waterEquivalent, `hydration log waterEquivalent for ${dateKey}`, validationErrors, 0);
                                const timestamp = parseAndValidateDate(log.timestamp, `hydration log timestamp for ${dateKey}`, validationErrors);
                                
                                if (type && quantity !== null && waterEquivalent !== null && timestamp !== null) {
                                    return true;
                                }
                                validationErrors.push(`Skipping invalid hydration sub-log for ${dateKey}: ${JSON.stringify(log)}`);
                                return false;
                            }) : [];
                            if (totalIntake !== null) {
                                newHydrationLogs[dateKey] = { totalIntake, logs };
                            } else {
                                validationErrors.push(`Skipping hydration log for ${dateKey} due to invalid totalIntake.`);
                            }
                        }
                        console.log("Hydration logs processed.");
                    } else if (importedData.hydrationLogs !== undefined) {
                        validationErrors.push('Invalid hydrationLogs data: Expected an object.');
                    }

                    // --- Validate Metadata ---
                    if (typeof importedData.metadata === 'object' && importedData.metadata !== null) {
                        newDailyWaterNeed = parseAndValidateNumber(importedData.metadata.dailyWaterNeed, 'dailyWaterNeed', validationErrors, 0) || 0;
                        console.log("Metadata processed.");
                    } else if (importedData.metadata !== undefined) {
                        validationErrors.push('Invalid metadata: Expected an object.');
                    }

                    if (validationErrors.length > 0) {
                        const errorReport = `Data imported with warnings/errors:\n- ${validationErrors.join('\n- ')}\n\nOnly valid data was imported.`;
                        console.warn(errorReport);
                        importStatusEl.innerHTML = `<p class="text-yellow-600 font-semibold">Import completed with warnings:</p><pre class="text-xs text-yellow-700 whitespace-pre-wrap">${errorReport}</pre>`;
                        importStatusEl.classList.remove('loading-text', 'text-green-600', 'text-red-600');
                        importStatusEl.classList.add('text-yellow-600');
                    } else {
                        importStatusEl.textContent = 'Data imported successfully!';
                        importStatusEl.classList.remove('loading-text');
                        importStatusEl.classList.add('text-green-600');
                    }

                    // Apply validated data
                    moodLogs = newMoodLogs;
                    habits = newHabits;
                    dailyHabitStatuses = newDailyHabitStatuses;
                    sleepLogs = newSleepLogs;
                    breathLogs = newBreathLogs;
                    hydrationLogs = newHydrationLogs;
                    dailyWaterNeed = newDailyWaterNeed; // Update global variable directly
                    const todayKey = toYYYYMMDD(new Date());
                    dailyIntake = hydrationLogs[todayKey] ? hydrationLogs[todayKey].totalIntake : 0; // Recalculate daily intake
                    console.log("Global variables updated with imported data.");

                    saveData(); // Save all to local storage
                    console.log("Data saved to local storage after import.");
                    calculateHabitStreaks();
                    renderContentForSection(document.querySelector('.nav-link.active').dataset.target); // Re-render current section
                    console.log("UI re-rendered after import.");

                }, () => {
                    importStatusEl.textContent = 'Import cancelled.';
                    importStatusEl.classList.remove('loading-text');
                    console.log("Import cancelled by user.");
                }, 'Import', 'bg-blue-600'); // Pass custom text and color for "OK" button

            };
            reader.readAsText(file);
        }


        // --- Initialization & Listeners ---
        function attachGlobalListeners() {
            document.querySelectorAll('.nav-link').forEach(l => l.addEventListener('click', () => showSection(l.dataset.target)));
            document.getElementById('close-habit-modal').addEventListener('click', () => toggleModal(habitModal, false));
            document.getElementById('cancel-habit-modal').addEventListener('click', () => toggleModal(habitModal, false));
            document.getElementById('habit-form').addEventListener('submit', handleHabitFormSubmit);
            document.getElementById('habit-frequency').addEventListener('change', (e) => document.getElementById('specific-days-container').classList.toggle('expanded', e.target.value === 'specific-days'));
            document.getElementById('confirm-modal-cancel').addEventListener('click', () => toggleModal(confirmModal, false)); // This is now handled by showConfirmation's onCancel
            document.getElementById('confirm-modal-ok').addEventListener('click', () => { if (confirmCallback) confirmCallback(); toggleModal(confirmModal, false); });
            
            appContainer.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                if(!target) return;
                
                if(target.classList.contains('habit-status-btn')) handleHabitStatusUpdate(target.dataset.habitId, target.dataset.status);
                else if(target.classList.contains('delete-mood-btn')) showConfirmation('Delete Mood Log?', 'This will be permanent.', () => {
                    moodLogs = moodLogs.filter(log => log.id !== target.dataset.id);
                    saveData();
                    renderContentForSection('mood-logging-section');
                    renderContentForSection('dashboard-section');
                    renderContentForSection('calendar-section');
                    renderContentForSection('analytics-section');
                });
                else if(target.id === 'add-new-habit-btn') openHabitModal();
                else if(target.classList.contains('edit-habit-btn')) openHabitModal(habits.find(h => h.id === target.dataset.id));
                else if(target.classList.contains('archive-toggle-habit-btn')) archiveHabit(target.dataset.id); // New
                else if(target.classList.contains('delete-habit-btn')) deleteHabit(target.dataset.id); // Re-added showConfirmation call here
                else if(target.classList.contains('calendar-nav-btn')) {
                    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + parseInt(target.dataset.direction, 10));
                    renderContentForSection('calendar-section');
                } else if(target.classList.contains('analytics-filter-btn')) {
                    target.parentElement.querySelectorAll('.analytics-filter-btn').forEach(b => b.classList.remove('active'));
                    target.classList.add('active');
                    const chartType = target.dataset.chart;
                    const period = target.dataset.period;
                    
                    if (chartType === 'summary') {
                        renderSummaryStatistics(period);
                        document.querySelector('#insights-container').innerHTML = renderCorrelationInsights(period); 
                    } else if (chartType === 'correlation-insights') {
                        document.querySelector('#insights-container').innerHTML = renderCorrelationInsights(period);
                    } else {
                        switch(chartType) {
                            case 'mood': renderMoodTrendChart(period); break;
                            case 'habit': renderHabitCompletionChart(period); break;
                            case 'sleep': renderSleepTrendChart(period); break;
                            case 'hydration': renderHydrationTrendChart(period); break;
                            case 'breath': renderBreathTrendChart(period); break;
                        }
                    }
                } else if (target.id === 'log-mood-btn') handleLogMood();
                else if (target.id === 'get-mood-insight-btn') generateMoodInsight(); 
                else if (target.id === 'suggest-habits-btn') {
                    generateHabitSuggestions(); 
                } else if (target.id === 'get-journal-prompt-btn') { // New Journal Prompt button
                    generateJournalPrompt();
                }
                else if (target.id === 'calculate-water-need-btn') calculateWaterNeed(); 
                else if (target.classList.contains('log-drink-btn')) { 
                    const drinkType = target.dataset.drinkType;
                    const quantityInput = document.getElementById(`log-${drinkType}-qty`);
                    const quantity = parseInt(quantityInput.value);
                    if (!isNaN(quantity) && quantity > 0) {
                        logHydration(drinkType, quantity);
                    } else {
                        console.warn(`Invalid quantity for ${drinkType}: ${quantityInput.value}`);
                        quantityInput.value = 250; 
                    }
                } else if (target.id === 'log-sleep-btn') { 
                    handleLogSleep();
                } else if (target.classList.contains('delete-sleep-log-btn')) { 
                    deleteSleepLog(target.dataset.id); 
                } else if (target.id === 'start-breathing-btn') { 
                    startBreathing();
                } else if (target.id === 'stop-breathing-btn') {
                    stopBreathing();
                } else if (target.id === 'log-breathing-session-btn') { 
                    if (sessionStartTime) {
                        const elapsedTime = (Date.now() - sessionStartTime) / 1000;
                        handleLogBreathingSession(elapsedTime);
                    } else {
                        handleLogBreathingSession(0);
                    }
                } else if (target.classList.contains('delete-breath-log-btn')) { 
                    deleteBreathLog(target.dataset.id);
                } else if (target.id === 'generate-recommendations-btn') { 
                    const activePeriodButton = document.querySelector('#recommendations-filter-buttons .recommendation-filter-btn.active');
                    const period = activePeriodButton ? activePeriodButton.dataset.period : '7days';
                    generatePersonalizedRecommendations(period);
                } else if (target.classList.contains('recommendation-filter-btn')) {
                    document.querySelectorAll('.recommendation-filter-btn').forEach(btn => btn.classList.remove('active'));
                    target.classList.add('active');
                    generatePersonalizedRecommendations(target.dataset.period);
                } else if (target.id === 'export-data-btn') { // New Export button
                    exportDataToJson();
                }
            });

             appContainer.addEventListener('input', e => {
                const target = e.target;
                if (target.id === 'mood-slider') {
                    document.getElementById('mood-value').textContent = target.value;
                    document.getElementById('mood-emoji').textContent = MOOD_EMOJIS[target.value - 1];
                } else if (target.id === 'sleep-quality-slider') { // New sleep quality slider
                    document.getElementById('sleep-quality-value').textContent = target.value;
                }
            });

            // Listener for toggling archived habits
            document.addEventListener('change', (e) => {
                if (e.target.id === 'toggle-archived-habits') {
                    localStorage.setItem('showArchivedHabits', e.target.checked);
                    renderContentForSection('habit-tracking-section');
                } else if (e.target.id === 'import-file-input') { // Enable import button when file is selected
                    document.getElementById('import-data-btn').disabled = !e.target.files.length;
                }
            });
            document.addEventListener('click', (e) => {
                if (e.target.id === 'import-data-btn') {
                    const fileInput = document.getElementById('import-file-input');
                    if (fileInput.files.length > 0) {
                        importDataFromJson({ target: { files: fileInput.files } });
                    }
                }
            });

        }
        
        async function initializeApp() {
            loadData();
            loadNotificationsSent(); 

            checkAndResetHabits();

            calculateHabitStreaks();

            userInfo.textContent = `ID: Local User`;

            hasInitialDataLoaded = true;
            const activeNavLink = document.querySelector('.nav-link.active');
            const currentSectionId = activeNavLink ? activeNavLink.dataset.target : 'dashboard-section';
            showSection(currentSectionId);
            appContainer.classList.remove('opacity-0');
            console.log("Local Storage: All initial data loaded and UI rendered successfully.");

            requestNotificationPermission();

            await analyzeMissingSleepAnalysesOnLoad(); 

            setInterval(saveData, 60000); 

            setInterval(scheduleHabitNotifications, 60000);
        }

        const requestNotificationPermission = () => { if ("Notification" in window && Notification.permission !== "denied") Notification.requestPermission(); };
        const showHabitNotification = (name) => { if (Notification.permission === "granted") new Notification("Habit Completed!", { body: `Great job: "${name}"!`, icon: "https://cdn-icons-png.flaticon.com/512/3448/3448338.png" }); };
        
        document.addEventListener('DOMContentLoaded', () => {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            document.querySelector('#specific-days-container div').innerHTML = days.map(day => `
                <label class="inline-flex items-center p-2 rounded-lg bg-gray-100 cursor-pointer">
                    <input type="checkbox" class="form-checkbox text-indigo-600" value="${day}"><span class="ml-2">${day}</span>
                </label>`).join('');
            
            attachGlobalListeners();
            initializeApp(); 
        });
    </script>
</body>
</html>
